<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      03｜强一致性：别再用BASE做借口，来看看什么是真正的事务一致性 - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式数据库30讲/02.基础篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式数据库30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/分布式数据库30讲/01.开篇词/01"><span>开篇词｜为什么要学习分布式数据库？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲/02.基础篇">02.基础篇</a><ul><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/01"><span>01｜什么是分布式数据库？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/02"><span>02｜强一致性：那么多数据一致性模型，究竟有啥不一样？</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲/02.基础篇/03"><span>03｜强一致性：别再用BASE做借口，来看看什么是真正的事务一致性</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/04"><span>04 | 架构风格：NewSQL和PGXC到底有啥不一样？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/05"><span>05 | 全局时钟：物理时钟和逻辑时钟你Pick谁？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/06"><span>06 | 分片机制：为什么说Range是更好的分片策略？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/07"><span>07 | 数据复制：为什么有时候Paxos不是最佳选择？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/08"><span>08 | 基础篇大串讲：重难点回顾+思考题答疑+知识全景图</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇">03.开发篇</a><ul><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/01"><span>09｜原子性：2PC还是原子性协议的王者吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/02"><span>10 | 原子性：如何打破事务高延迟的魔咒？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/03"><span>11｜隔离性：读写冲突时，快照是最好的办法吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/04"><span>12 | 隔离性：看不见的读写冲突，要怎么处理？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/05"><span>13 | 隔离性：为什么使用乐观协议的分布式数据库越来越少?</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06"><span>14 | 隔离性：实现悲观协议，除了锁还有别的办法吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/07"><span>15 | 分布式事务串讲：重难点回顾+思考题答疑+知识全景图</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/08"><span>16 | 为什么不建议你使用存储过程？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/09"><span>17 | 为什么不建议你使用自增主键？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/10"><span>18 | HTAP是不是赢者通吃的游戏？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/11"><span>19 | 查询性能优化：计算与存储分离架构下有哪些优化思路？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/12"><span>20 | 关联查询：如何提升多表Join能力？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/13"><span>21 | 查询执行引擎：如何让聚合计算加速？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/14"><span>22｜RUM猜想：想要读写快还是存储省？又是三选二</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/15"><span>23 | 数据库查询串讲：重难点回顾+思考题答疑+知识全景图</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇">04.实践篇</a><ul><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/01"><span>24 | 全球化部署：如何打造近在咫尺且永不宕机的数据库？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/02"><span>25 | 容灾与备份：如何设计逃生通道保证业务连续性？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/03"><span>26 | 容器化：分布式数据库要不要上云，你想好了吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/04"><span>27 | 产品测试：除了性能跑分，还能测个啥？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/05"><span>28 | 选型案例：银行是怎么选择分布式数据库的？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/06"><span>29 | 产品图鉴：哪些分布式数据库值得看？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/07"><span>30 | 实践篇大串讲：重难点回顾+思考题答疑+知识全景图</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/05.结束语">05.结束语</a><ul><li><a href="/blog-architect2/分布式数据库30讲/05.结束语/01"><span>结束语 | 享受职业带给你的快乐</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/06.测试题">06.测试题</a><ul><li><a href="/blog-architect2/分布式数据库30讲/06.测试题/01"><span>结课测试｜这些分布式数据库的问题，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/07.用户故事">07.用户故事</a><ul><li><a href="/blog-architect2/分布式数据库30讲/07.用户故事/01"><span>用户故事 | 李兆龙：博观而约取，厚积而薄发</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/summary">分布式数据库30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="事务的ACID特性" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#事务的acid特性"><span>事务的ACID特性</span></a></li><li title="ANSI SQL-92：对隔离级别最早、最正式的定义" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#ansi-sql-92对隔离级别最早最正式的定义"><span>ANSI SQL-92：对隔离级别最早、最正式的定义</span></a></li><li title="Critique：更严谨的隔离级别" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#critique更严谨的隔离级别"><span>Critique：更严谨的隔离级别</span></a></li><li title="幻读和写倾斜" data-depth="3"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#幻读和写倾斜"><span>幻读和写倾斜</span></a></li><li title="快照隔离 &amp; MVCC" data-depth="3"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#快照隔离--mvcc"><span>快照隔离 &amp; MVCC</span></a></li><li title="隔离性的产品实现" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#隔离性的产品实现"><span>隔离性的产品实现</span></a></li><li title="分布式数据库的强一致性" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#分布式数据库的强一致性"><span>分布式数据库的强一致性</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03强一致性别再用base做借口来看看什么是真正的事务一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#03强一致性别再用base做借口来看看什么是真正的事务一致性"><span class="icon icon-link"></span></a>03｜强一致性：别再用BASE做借口，来看看什么是真正的事务一致性</h1><p>你好，我是王磊，你也可以叫我Ivan。</p><p>在上一讲的开头，我提了一个问题：对分布式数据库来说，“强一致性”意味着什么？我们经过分析后得出的结论是这个强一致性，包括数据一致性和事务一致性两个方面。然后，我们介绍了数据一致性是怎么回事儿。那么，今天我们会继续这个话题，谈谈事务一致性。</p><p>每次，我和熟悉NoSQL同学聊到事务这个话题时，都会提到ACID和BASE。甚至，不少同学会觉得ACID有些落伍了，以BASE为理论基础的NoSQL，才是当下的潮流。</p><p>那我们来看看BASE是什么？其实，它代表了三个特性，BA表示基本可用性（Basically Available），S表示软状态（Soft State），E表示最终一致性（Eventual Consistency）：</p><ul><li>基本可用性，是指某些部分出现故障，那么系统的其余部分依然可用。</li><li>软状态或柔性事务，是指数据处理过程中，存在数据状态暂时不一致的情况，但最终会实现事务的一致性。</li><li>最终一致性，是指单数据项的多副本，经过一段时间，最终达成一致。这个，我们在第2讲已经详细说过了。</li></ul><p>总体来说，BASE是一个很宽泛的定义，所做的承诺非常有限。我认为，BASE的意义只在于放弃了ACID的一些特性，从而更简单地实现了高性能和可用性，达到一个新的平衡。但是，架构设计上的平衡往往都是阶段性的，随着新技术的突破，原来的平衡点也自然会改变。你看，不用说分布式数据库，就连不少NoSQL也开始增加对事务的支持了。</p><p>所以说，风水轮流转，今天ACID已经是新的后浪了。</p><h2 id="事务的acid特性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#事务的acid特性"><span class="icon icon-link"></span></a>事务的ACID特性</h2><p>在数据库中，“事务”是由多个操作构成的序列。1970年詹姆斯 · 格雷（Jim Gray）提出了事务的ACID四大特性，将广义上的事务一致性具化到了原子性、一致性、隔离性和持久性这4个方面。我们先来看一下他在 <em>Transaction Processing Concepts and Techniques</em> 中给出的定义：</p><blockquote><p><strong>Atomicity</strong>: <em>Either all the changes from the transaction occur (writes, and messages sent), or none occur.</em></p></blockquote><blockquote><p><strong>Consistency</strong>: <em>The transaction preserves the integrity of stored information.</em></p></blockquote><blockquote><p><strong>Isolation</strong>: <em>Concurrently executing transactions see the stored information as if they were running serially (one after another).</em></p></blockquote><blockquote><p><strong>Durability</strong>: <em>Once a transaction commits, the changes it made (writes and messages sent) survive any system failures.</em></p></blockquote><p>翻译过来的意思就是：</p><blockquote><p>原子性：事务中的所有变更要么全部发生，要么一个也不发生。</p></blockquote><blockquote><p>一致性：事务要保持数据的完整性。</p></blockquote><blockquote><p>隔离性：多事务并行执行所得到的结果，与串行执行（一个接一个）完全相同。</p></blockquote><blockquote><p>持久性：一旦事务提交，它对数据的改变将被永久保留，不应受到任何系统故障的影响。</p></blockquote><p>虽然ACID名义上并列为事务的四大特性，但它们对于数据库的重要程度并不相同。我用一张图来表示它们的关系。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagee773e7571fa45b9337f2541a35d8c82b3873.bdde74ed.jpg" alt=""/></p><p>我们依次来看下。</p><p>第一个是一致性，它无疑是其中存在感最低的特性，可以看作是对 “事务”整体目标的阐述。它并没有提出任何具体的功能需求，所以在数据库中也很难找到针对性的设计。</p><p>第二个是持久性，它不仅是对数据库的基本要求。如果你仔细琢磨下持久性的定义，就会发现它的核心思想就是要应对系统故障。怎么理解系统故障呢？我们可以把故障分为两种。</p><ol><li><p>存储硬件无损、可恢复的故障。这种情况下，主要依托于预写日志（Write Ahead Log, WAL）保证第一时间存储数据。WAL采用顺序写入的方式，可以保证数据库的低延时响应。WAL是单体数据库的成熟技术，NoSQL和分布式数据库都借鉴了过去。</p></li><li><p>存储硬件损坏、不可恢复的故障。这种情况下，需要用到日志复制技术，将本地日志及时同步到其他节点。实现方式大体有三种：第一种是单体数据库自带的同步或半同步的方式，其中半同步方式具有一定的容错能力，实践中被更多采用；第二种是将日志存储到共享存储系统上，后者会通过冗余存储保证日志的安全性，亚马逊的Aurora采用了这种方式，也被称为Share Storage；第三种是基于Paxos/Raft的共识算法同步日志数据，在分布式数据库中被广泛使用。无论采用哪种方式，目的都是保证在本地节点之外，至少有一份完整的日志可用于数据恢复。</p></li></ol><p>第三个是原子性，是数据库区别于其他存储系统的重要标志。在单体数据库时代，原子性问题已经得到妥善解决，但随着向分布式架构的转型，在引入不可靠的网络因素后，原子性又成为一个新的挑战。</p><p>要在分布式架构下支持原子性并不容易，所以不少NoSQL产品都选择绕过这个问题，聚焦到那些对原子性不敏感的细分场景。例如，大名鼎鼎的Google BigTable甚至是不支持跨行事务的。但是，这种妥协也造成了NoSQL的通用性不好。</p><p>我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/271369">开篇词<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>就说过，这门课程讨论的分布式数据库是在分布式架构上实现的关系型数据库，那么就必须支持事务，首先就要支持原子性。原子性，在实现机制上较为复杂，目标却很简单，和分成多个级别的隔离性不同，原子性就只有支持和不支持的区别。有关原子性的实现机制，我将在第9讲中专门介绍。</p><p>最后一个是隔离性，它是事务中最复杂的特性。隔离性分为多个隔离级别，较低的隔离级别就是在正确性上做妥协，将一些异常现象交给应用系统的开发人员去解决，从而获得更好的性能。</p><p>可以说，事务模型的发展过程就是在隔离性和性能之间不断地寻找更优的平衡点。我觉得，甚至可以说事务的核心就是隔离性。而不同产品在事务一致性上的差别，也完全体现在隔离性的实现等级上，所以我们必须搞清楚隔离等级具体是指什么。</p><h2 id="ansi-sql-92对隔离级别最早最正式的定义"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#ansi-sql-92对隔离级别最早最正式的定义"><span class="icon icon-link"></span></a>ANSI SQL-92：对隔离级别最早、最正式的定义</h2><p>最早、最正式的对隔离级别的定义，是ANSI SQL-92（简称SQL-92），它定义的隔离级别和异常现象如下所示：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageed44ed89859eb0f1108600e0d5f0db343544.ad512de2.jpg" alt=""/></p><p>SQL-92定义了四个隔离级别和三种异常现象，这些内容网上很多文章都说得比较清楚，我就不再啰嗦了。如果还不放心，我推荐你去看林晓斌老师的课程《MySQL实战45讲》。</p><p>不过，虽然SQL-92得到了广泛应用，不少数据库也都遵照这个标准来命名自己的隔离级别，但它对异常现象的分析还是过于简单了。所以在不久之后的1995年，Jim Gray等人发表了论文“<a target="_blank" rel="noopener noreferrer" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”（以下简称Critique），对于事务隔离性进行了更加深入的分析。我要特别提示一下，Critique是数据库领域的经典论文，强烈推荐你阅读原文。</p><h2 id="critique更严谨的隔离级别"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#critique更严谨的隔离级别"><span class="icon icon-link"></span></a>Critique：更严谨的隔离级别</h2><h3 id="幻读和写倾斜"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#幻读和写倾斜"><span class="icon icon-link"></span></a>幻读和写倾斜</h3><p>Critique丰富和细化了SQL-92的内容，定义了六种隔离级别和八种异常现象。其中，我们最关注的是快照隔离（Snapshot Isolation, SI）级别。为什么呢？这是因为在SQL-92中可重复读（Repeatable Read, RR）与可串行化（Serializable）两个隔离级别的主要差别是对幻读（Phantom）的处理。这似乎是说，解决幻读问题的就是可串行化。但随着Critique的发表，快照隔离被明确提出，这个说法就不适用了，因为快照隔离能解决幻读的问题，但却无法处理写倾斜（Write Skew）问题，也不符合可串行化要求。因为翻译的原因，有时写倾斜也被称为写偏序，都是一个意思。</p><p>因此，今天，使用最广泛的隔离级别有四个，就是已提交读、可重复读、快照隔离、可串行化。</p><p>而幻读和写倾斜无疑则是通往最高隔离级别的两座大山，那么让我来给你详细解释一下它们到底是什么异常现象。</p><p>Critique对幻读的描述大致是这样的，事务T1使用特定的查询条件获得一个结果集，事务T2插入新的数据，并且这些数据符合T1刚刚执行的查询条件。T2 提交成功后，T1再次执行同样的查询，此时得到的结果集会增大。这种异常现象就是幻读。</p><p>不少人会将幻读与不可重复读混淆，这是因为它们在自然语义上非常接近，都是在一个事务内用相同的条件查询两次，但两次的结果不一样。差异在于，对不可重复读来说，第二次的结果集相对第一次，有些记录被修改（Update）或删除（Delete）了；而幻读是第二次结果集里出现了第一次结果集没有的记录(Insert)。一个更加形象的说法，幻读是在第一次结果集的记录“间隙”中增加了新的记录。所以，MySQL将防止出现幻读的锁命名为间隙锁（Gap Lock）。</p><p>跟幻读相比，写倾斜要稍微复杂一点，我用一个黑白球的例子来说明。</p><p>首先，箱子里有三个白球和三个黑球，两个事务（T1,T2）并发修改，不知道对方的存在。T1要让6个球都变成白色；T2则希望6个球都变成黑色。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage91fa91e75e61d921fb21cebfdba8879806fa.7ff3ad65.jpg" alt=""/></p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageddbeddce93423da417ef495b2bbc7c3090be.156b1b2f.jpg" alt=""/></p><p>你看，最终的执行结果是，盒子里仍然有三个黑球和三个白球。如果你还没有发现问题，可以看看下面我画的串行执行的效果图，比较一下有什么不同。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage85838502cf4cf0f6fe61db1692bd1a945883.92a0ed3d.jpg" alt=""/></p><p>如果先执行T1再执行T2，6个球都会变成黑色；调换T1与T2的顺序，则6个球都是白色。</p><p>根据可串行化的定义，“多事务并行执行所得到的结果，与串行执行（一个接一个）完全相同”。比照两张图，很容易发现事务并行执行没有达到串行的同等效果，所以这是一种异常现象。也可以说，写倾斜是一种更不易察觉的更新丢失。</p><p>好了，为了让你搞清Critique中六种隔离级别的强弱关系以及相互间的差距，我截取了原论文的一张配图。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage0daa0d81415e08f4507d5f3f3ff6f99a99aa.98e5c749.jpg" alt=""/></p><p>你可以看到“快照隔离”与“可重复读”在强度上并列，“已提交读”则弱于这两者。事实上，今天大多数数据库支持的隔离级别就在这三者之中。</p><h3 id="快照隔离--mvcc"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#快照隔离--mvcc"><span class="icon icon-link"></span></a>快照隔离 &amp; MVCC</h3><p>你可能会问，既然“快照隔离”这么重要，为什么会被SQL-92漏掉呢？</p><p>这是由于SQL-92主要考虑了基于锁（Lock-base）的并发控制，而快照隔离的实现基础则是多版本并发控制（MVCC），很可能是由于当时MVCC的应用还不普遍。当然，后来，MVCC成为一项非常重要的技术，一些经典教材会将MVCC作为一种独立的选择，与乐观并发控制和悲观并发控制并列。其实，在现代数据库中MVCC已经成为一种底层技术，用于更高效地实现乐观或悲观并发控制。有了MVCC这个基础，快照隔离就成为一个普遍存在的隔离级别了。有关MVCC的话题，我会在第11讲中继续展开。</p><h2 id="隔离性的产品实现"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#隔离性的产品实现"><span class="icon icon-link"></span></a>隔离性的产品实现</h2><p>还有一个问题也许你一直想问，为什么不支持最高级别的可串行化呢？</p><p>答案可能会让你有点沮丧，那就是在很长一段时间内，学术界都没有找到足够高效的并发控制技术。可能你熟悉的很多数据库声称提供了“可串行化”级别，但这往往只是一种形象工程，因为它们都采用的是两阶段封锁协议，导致性能无法满足生产环境的要求。不过，有些消息让人振奋，虽然不是普适的方案，但少数产品的尝试已经取得进展。</p><p>这种尝试来自两个方向。</p><p>第一个方向是，用真正的串行化实现“可串行化”隔离。我们往往认为多线程并发在性能上更优，但Redis和VoltDB确实通过串行化执行事务的方式获得了不错的性能。考虑到VoltDB作为一款分布式数据库的复杂度，其成功就更为难得了。我想，其中部分原因可能在于内存的大量使用，加速了数据计算的过程。另外，VoltDB以存储过程为逻辑载体的方式，也使得事务有了更多的优化机会。</p><p>如果说第一个方向有点剑走偏锋，那第二个方向就是硬桥硬马了。没错，还是在并发技术上继续做文章。PostgreSQL在2008年提出了Serializable Snapshot Isolation (SSI)，这实际就是可串行化。而后，兼容PostgreSQL生态的CockroachDB，也同样选择支持SSI，而且是唯一支持的隔离级别。</p><p>这两个方向的尝试都很有趣，我还会在后续的课程中与你深入探讨。</p><h2 id="分布式数据库的强一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#分布式数据库的强一致性"><span class="icon icon-link"></span></a>分布式数据库的强一致性</h2><p>到这里，我们用两讲的篇幅分别介绍了数据一致性和事务一致性，它们共同构成了分布式数据库的强一致性这个概念。我借用一张图来体现三者的关系。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagec2c2c291e740e57dbedc2e20f18fd62b1ec2.fcb9ad6b.jpg" alt=""/></p><p>图片原始出处是论文“Highly Available Transactions: Virtues and Limitations”，此处引用的是<a target="_blank" rel="noopener noreferrer" href="https://jepsen.io/consistency">Jepsen网站的简化版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>这幅图展现了一个树状结构，左右两个分支上体现事务一致性和数据一致性的各个级别及强弱关系，根节点则体现了分布式数据库的一致性来自两者的融合。图中使用了不同颜色，简单来说，这是区别不同的一致性级别所需付出的性能代价。</p><p>对分布式数据而言，最高级别的一致性是严格串行化（Strict Serializable），Spanner实现的“外部数据一致性”可以被视为与 “Strict Serializable” 等效。但由于两条路径上各自实现难度及性能上的损耗，少有分布式数据库在顶端汇合。即使强大的Spanner也提供了有界旧一致性（Bounded Stale），用于平衡性能和一致性之间的冲突。</p><p>下面，我总结了一些分布式数据库产品的“一致性”实现情况供你参考。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagee5d9e58acbd91d1f25fa4086eb8yyc9decd9.11298326.jpg" alt=""/></p><p>比较特别的是，OceanBase在2.2版本还增加了对“可串行化”的支持，但这是一个被Oracle重新定义的“可串行化”，在这个级别OceanBase和Oracle一样都会出现写倾斜。所以，这不是我们标准的隔离级别，也就没有体现在表格中。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，有关事务一致性就讨论到这里，最后让我们来回顾一下今天的重点内容。</p><ol><li>数据一致性关注的是单对象、单操作在多副本上的一致性，事务一致性则是关注多对象、多操作在单副本上的一致性，分布式数据库的一致性是数据一致性与事务一致性的融合。</li><li>广义上的事务一致性被细化为ACID四个方面，其中原子性的实现依赖于隔离性的并发控制技术和持久性的日志技术。</li><li>隔离性是事务的核心。降低隔离级别，其实就是在正确性上做妥协，将一些异常现象交给应用系统的开发人员去解决，从而获得更好的性能。所以，除“可串行化”以外的隔离级别，都有无法处理的异常现象。</li><li>研究人员将隔离级别分为六级，你需要重点关注其中四个，分别是已提交读、可重复读、快照隔离、可串行化。前三者是单体数据库或分布式数据库中普遍提供的，可串行化仅在少数产品中提供。</li></ol><p>好了，到这里，加上前一节“数据一致性”，我们用了两讲阐述了分布式数据“强一致性”的含义。在严格意义上，分布式数据库的“强一致性”意味着严格串行化（Strict Serializable），目前我们熟知的产品中只有Spanner达到了这个标准，其同时也带来了性能上的巨大开销。如果我们稍稍放松标准，那么“数据一致性”达到因果一致性且“事务一致性”达到已提交读，即可认为是相对的“强一致性”。还有一点非常重要，分布式数据一致性并不是越高越好，还要与可用性、性能指标结合，否则就成了形象工程。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagec5edc57e399d116cd88e1062184fb97d3aed.f225162a.jpg" alt=""/></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/02.基础篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>课程的最后，我要留给你一道思考题。</p><p>我们在事务持久性部分提到了预写日志（WAL），它可以保证在系统发生故障时，数据也不会丢失。但是，如果写日志成功，而写数据表失败，又要如何处理呢？你可以根据自己的经验，讲讲该如何设计这个过程吗？</p><p>欢迎你在评论区留言和我一起讨论，我会在答疑篇回复这个问题。如果你身边的朋友也对事务一致性这个话题感兴趣，你也可以把今天这一讲分享给他，我们一起讨论。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式数据库30讲/02.基础篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
