<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>14 | 隔离性：实现悲观协议，除了锁还有别的办法吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式数据库30讲/03.开发篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式数据库30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/分布式数据库30讲/01.开篇词/01"><span>开篇词｜为什么要学习分布式数据库？</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇">02.基础篇</a><ul><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/01"><span>01｜什么是分布式数据库？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/02"><span>02｜强一致性：那么多数据一致性模型，究竟有啥不一样？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/03"><span>03｜强一致性：别再用BASE做借口，来看看什么是真正的事务一致性</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/04"><span>04 | 架构风格：NewSQL和PGXC到底有啥不一样？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/05"><span>05 | 全局时钟：物理时钟和逻辑时钟你Pick谁？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/06"><span>06 | 分片机制：为什么说Range是更好的分片策略？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/07"><span>07 | 数据复制：为什么有时候Paxos不是最佳选择？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/02.基础篇/08"><span>08 | 基础篇大串讲：重难点回顾+思考题答疑+知识全景图</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲/03.开发篇">03.开发篇</a><ul><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/01"><span>09｜原子性：2PC还是原子性协议的王者吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/02"><span>10 | 原子性：如何打破事务高延迟的魔咒？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/03"><span>11｜隔离性：读写冲突时，快照是最好的办法吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/04"><span>12 | 隔离性：看不见的读写冲突，要怎么处理？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/05"><span>13 | 隔离性：为什么使用乐观协议的分布式数据库越来越少?</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式数据库30讲/03.开发篇/06"><span>14 | 隔离性：实现悲观协议，除了锁还有别的办法吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/07"><span>15 | 分布式事务串讲：重难点回顾+思考题答疑+知识全景图</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/08"><span>16 | 为什么不建议你使用存储过程？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/09"><span>17 | 为什么不建议你使用自增主键？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/10"><span>18 | HTAP是不是赢者通吃的游戏？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/11"><span>19 | 查询性能优化：计算与存储分离架构下有哪些优化思路？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/12"><span>20 | 关联查询：如何提升多表Join能力？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/13"><span>21 | 查询执行引擎：如何让聚合计算加速？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/14"><span>22｜RUM猜想：想要读写快还是存储省？又是三选二</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/03.开发篇/15"><span>23 | 数据库查询串讲：重难点回顾+思考题答疑+知识全景图</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇">04.实践篇</a><ul><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/01"><span>24 | 全球化部署：如何打造近在咫尺且永不宕机的数据库？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/02"><span>25 | 容灾与备份：如何设计逃生通道保证业务连续性？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/03"><span>26 | 容器化：分布式数据库要不要上云，你想好了吗？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/04"><span>27 | 产品测试：除了性能跑分，还能测个啥？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/05"><span>28 | 选型案例：银行是怎么选择分布式数据库的？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/06"><span>29 | 产品图鉴：哪些分布式数据库值得看？</span></a></li><li><a href="/blog-architect2/分布式数据库30讲/04.实践篇/07"><span>30 | 实践篇大串讲：重难点回顾+思考题答疑+知识全景图</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/05.结束语">05.结束语</a><ul><li><a href="/blog-architect2/分布式数据库30讲/05.结束语/01"><span>结束语 | 享受职业带给你的快乐</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/06.测试题">06.测试题</a><ul><li><a href="/blog-architect2/分布式数据库30讲/06.测试题/01"><span>结课测试｜这些分布式数据库的问题，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/07.用户故事">07.用户故事</a><ul><li><a href="/blog-architect2/分布式数据库30讲/07.用户故事/01"><span>用户故事 | 李兆龙：博观而约取，厚积而薄发</span></a></li></ul></li><li><a href="/blog-architect2/分布式数据库30讲/summary">分布式数据库30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="悲观协议的分类" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#悲观协议的分类"><span>悲观协议的分类</span></a></li><li title="两阶段封锁（Two-Phase Locking，2PL）" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#两阶段封锁two-phase-locking2pl"><span>两阶段封锁（Two-Phase Locking，2PL）</span></a></li><li title="串行化图检测（SGT）" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#串行化图检测sgt"><span>串行化图检测（SGT）</span></a></li><li title="理论来源：PostgreSQL" data-depth="3"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#理论来源postgresql"><span>理论来源：PostgreSQL</span></a></li><li title="工程实现：CockroachDB" data-depth="3"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#工程实现cockroachdb"><span>工程实现：CockroachDB</span></a></li><li title="相对乐观" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#相对乐观"><span>相对乐观</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#思考题"><span>思考题</span></a></li><li title="学习资料" data-depth="2"><a href="/blog-architect2/分布式数据库30讲/03.开发篇/06#学习资料"><span>学习资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="14--隔离性实现悲观协议除了锁还有别的办法吗"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#14--隔离性实现悲观协议除了锁还有别的办法吗"><span class="icon icon-link"></span></a>14 | 隔离性：实现悲观协议，除了锁还有别的办法吗？</h1><p>你好，我是王磊，你也可以叫我Ivan。</p><p>我们今天的主题是悲观协议，我会结合<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/282401">第13讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的内容将并发控制技术和你说清楚。在第13讲我们以并发控制的三阶段作为工具，区分了广义上的乐观协议和悲观协议。因为狭义乐观很少使用，所以我们将重点放在了相对乐观上。</p><p>其实，相对乐观和局部悲观是一体两面的关系，识别它的要点就在于是否有全局有效性验证，这也和分布式数据库的架构特点息息相关。但是关于悲观协议，还有很多内容没有提及，下面我们就来填补这一大块空白。</p><h2 id="悲观协议的分类"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#悲观协议的分类"><span class="icon icon-link"></span></a>悲观协议的分类</h2><p>要搞清楚悲观协议的分类，其实是要先跳出来，从并发控制技术整体的分类体系来看。</p><p>事实上，并发控制的分类体系，连学术界的标准也不统一。比如，在第13讲提到的两本经典教材中，“<a target="_blank" rel="noopener noreferrer" href="https://link.springer.com/content/pdf/bfm%3A978-1-4419-8834-8%2F1.pdf">Principles of Distributed Database Systems<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”的分类是按照比较宽泛的乐观协议和悲观协议进行分类，子类之间又有很多重叠的概念，理解起来有点复杂。</p><p>而“<a target="_blank" rel="noopener noreferrer" href="http://www.gbv.de/dms/weimar/toc/647210940_toc.pdf">Transactional Information Systems : Theory, Algorithms, and the Practice of Concurrency Control and Recovery<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”采用的划分方式，是狭义乐观协议和其他悲观协议。这里狭义乐观协议，就是指我们在第13讲提到过的，基于有效性验证的并发控制，也是学术上定义的OCC。</p><p>我个人认为，狭义乐观协议和其他悲观协议这种分类方式更清晰些，所以就选择了“ Transactional Information Systems : Theory, Algorithms, and the Practice of Concurrency Control and Recovery”中的划分体系。下面我摘录了书中的一幅图，用来梳理不同的并发控制协议。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageeda1ede7edbb88108b76d015fa69d14425a1.0c532761.png" alt=""/></p><p>这个体系首先分为悲观和乐观两个大类。因为这里的乐观协议是指狭义乐观并发控制，所以包含内容就比较少，只有前向乐观并发控制和后向乐观并发控制；而悲观协议又分为基于锁和非锁两大类，其中基于锁的协议是数量最多的。</p><h2 id="两阶段封锁two-phase-locking2pl"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#两阶段封锁two-phase-locking2pl"><span class="icon icon-link"></span></a>两阶段封锁（Two-Phase Locking，2PL）</h2><p>基于锁的协议显然不只是2PL，还包括有序共享（Ordered Sharing 2PL, O2PL）、利他锁（Altruistic Locking, AL）、只写封锁树（Write-only Tree Locking, WTL）和读写封锁树（Read/Write Tree Locking， RWTL）。但这几种协议在真正的数据库系统中很少使用，所以就不过多介绍了，我们还是把重点放在数据库系统主要使用的2PL上。</p><p>2PL就是事务具备两阶段特点的并发控制协议，这里的两个阶段指加锁阶段和释放锁阶段，并且加锁阶段严格区别于紧接着的释放锁阶段。我们可以通过一张图来加深对2PL理解。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage5475540f30e8c3877b4951711e3c7305df75.e715deea.png" alt=""/></p><p>在t1时刻之前是加锁阶段，在t1之后则是释放锁阶段，我们可以从时间上明确地把事务执行过程划分为两个阶段。2PL的关键点就是释放锁之后不能再加锁。而根据加锁和释放锁时机的不同，2PL又有一些变体。</p><p><strong>保守两阶段封锁协议</strong>（Conservative 2PL，C2PL），事务在开始时设置它需要的所有锁。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage66816680049eacdd2bab61a65eyy0e36a881.b09b2e89.png" alt=""/></p><p><strong>严格两阶段封锁协议</strong>（Strict 2PL，S2PL），事务一直持有已经获得的所有写锁，直到事务终止。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageb7ecb7291c52385b627282f5c4f010acacec.0c9e8c9a.png" alt=""/></p><p><strong>强两阶段封锁协议</strong>（Strong Strict 2PL，SS2PL），事务一直持有已经获得的所有锁，包括写锁和读锁，直到事务终止。SS2PL与S2PL差别只在于一直持有的锁的类型，所以它们的图形是相同的。</p><p>理解了这几种2PL的变体后，我们再回想一下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/282401">第13讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的Percolator模型。当主锁（Primary Lock）没有释放前，所有的记录上的从锁（Secondary Lock）实质上都没有释放，在主锁释放后，所有从锁自然释放。所以，Percolator也属于S2PL。TiDB的乐观锁机制是基于Percolator的，那么TiDB就也是S2PL。</p><p>事实上，S2PL可能是使用最广泛的悲观协议，几乎所有单体数据都依赖S2PL实现可串行化。而在分布式数据库中，甚至需要使用SS2PL来保证可串行化执行，典型的例子是TDSQL。但S2PL模式下，事务持有锁的时间过长，导致系统并发性能较差，所以实际使用中往往不会配置到可串行化级别。这就意味着我们还是没有生产级技术方案，只能期望出现新的方式，既达到可串行化隔离级别，又能有更好的性能。最终，我们等到了一种可能是性能更优的工程化实现，这就是CockroachDB的串行化快照隔离（SSI）。而SSI的核心，就是串行化图检测（SGT）。</p><h2 id="串行化图检测sgt"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#串行化图检测sgt"><span class="icon icon-link"></span></a>串行化图检测（SGT）</h2><p>SSI是一种隔离级别的命名，最早来自PostgreSQL，CockroachDB沿用了这个名称。它是在SI基础上实现的可串行化隔离。同样，作为SSI核心的SGT也不是CockroachDB首创，学术界早就提出了这个理论，但真正的工程化实现要晚得多。</p><h3 id="理论来源postgresql"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#理论来源postgresql"><span class="icon icon-link"></span></a>理论来源：PostgreSQL</h3><p>PostgreSQL在论文“<a target="_blank" rel="noopener noreferrer" href="http://vldb.org/pvldb/vol5/p1850_danrkports_vldb2012.pdf">Serializable Snapshot Isolation in PostgreSQL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中最早提出了SSI的工程实现方案，这篇论文也被VLDB2012收录。</p><p>为了更清楚地描述SSI方案，我们先要了解一点理论知识。</p><p>串行化理论的核心是串行化图（Serializable Graph，SG）。这个图用来分析数据库事务操作的冲突情况。每个事务是一个节点，事务之间的关系则表示为一条有向边。那么，什么样的关系可以表示为边呢？</p><p>串行化图的构建规则是这样的，事务作为节点，当一个操作与另一个操作冲突时，在两个事务节点之间就可以画上一条有向边。</p><p>具体来说，事务之间的边又分为三类情况：</p><ol><li>写读依赖（WR-Dependencies），第二个操作读取了第一个操作写入的值。</li><li>写写依赖（WW-Dependencies），第二个操作覆盖了第一个操作写入的值。</li><li>读写反依赖（RW-Antidependencies），第二个操作覆盖了第一个操作读取的值，可能导致读取值过期。</li></ol><p>我们通过一个例子，看看如何用这几条规则来构建一个简单的串行化图。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage0d730ddedf5e27966fac0388f36ddde7f473.3464efbc.png" alt=""/></p><p>图中一共有三个事务先后执行，事务T1先执行W(A)，T2再执行R(A)，所以T1与T2之间存在WR依赖，因此形成一条T1指向T2的边；同理，T2的W(B)与T3的R(B)也存在WR依赖，T1的W(A)与T3的R(A)之间也是WR依赖，这样就又形成两条有向边，分别是T2指向T3和T1指向T3。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage7ef57e66dc945b0ed425781f1e922ed338f5.a88e5683.png" alt=""/></p><p>最终，我们看到产生了一个有向无环图（Directed Acyclic Graph，DAG）。能够构建出DAG，就说明相关事务是可串行化执行的，不需要中断任何事务。</p><p>我们可以使用SGT，验证一下典型的死锁情况。我们知道，事务T1和T2分别以不同的顺序写两个数据项，那么就会形成死锁。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagea27fa2042eef98d2a84556fcbfb1814b517f.23520478.png" alt=""/></p><p>用串行化图来体现就是这个样子，显然构成了环。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage88ef88d4955b226a9ee089cd8d361d86d0ef.74922c40.png" alt=""/></p><p>在SGT中，WR依赖和WW依赖都与我们的直觉相符，而RW反向依赖就比较难理解了。在PostgreSQL的论文中，专门描述了一个RW反向依赖的场景，这里我把它引用过来，我们一起学习一下。</p><p>这个场景一共需要维护两张表：一张收入表（reciepts）会记入当日的收入情况，每行都会记录一个批次号；另一张独立的控制表（current_batch），里面只有一条记录，就是当前的批次号。你也可以把这里的批次号理解为一个工作日。</p><p>同时，还有三个事务T1、T2、T3。</p><ul><li>T2是记录新的收入（NEW-RECEIPT），从控制表中读取当前的批次号，然后在收入表中插入一条新的记录。</li><li>T3负责关闭当前批次（CLOSE-BATCH），而具体实现是通过将控制表中的批次号递增的方式，这就意味着后续再发生的收入会划归到下一个批次。</li><li>T1是报告（REPORT），读取当前控制表的批次号，处理逻辑是用当前已经加一的批次号再减一。T1用这个批次号作为条件，读取收据表中的所有记录。查询到这个批次，也就是这一日，所有的交易。</li></ul><p>其实，这个例子很像银行存款系统的日终翻牌。</p><p>因为T1要报告当天的收入情况，所以它必须要在T3之后执行。事务T2记录了当天的每笔入账，必须在T3之前执行，这样才能出现在当天的报表中。三者顺序执行可以正常工作，否则就会出现异常，比如下面这样的：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageb201b2223b52a92e76f5dfe338e366238501.5953c663.png" alt=""/></p><p>T2先拿到一个批次号x，随后T3执行，批次号关闭后，x这个批次号其实已经过期，但是T2还继续使用x，记录当前的这笔收入。T1正常在T3后执行，此时T2尚未提交，所以T1的报告中漏掉了T2的那笔收入。因为T2使用时过期的批次号x，第二天的报告中也不会统计到这笔收入，最终这笔收入就神奇地消失了。</p><p>在理解了这个例子的异常现象后，我们用串行化图方法来验证一下。我们是把事务中的SQL抽象为对数据项的操作，可以得到下面这张图。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage887a884e0f7b80fc32b9b8491ee76f8f127a.3a19ab1e.png" alt=""/></p><p>图中batch是指批次号，reps是指收入情况。</p><p>接下来，我们按照先后顺序提取有向边，先由T2.R(batch) -&gt; T3.W(batch)，得到T2到T3的RW依赖；再由T3.W(batch)-&gt;T1.R(batch)，得到 T3到T1的WR依赖；最后由T1.R(reps)-&gt;T2.W(reps)，得到T1到T2的RW依赖。这样就构成了下面的串行化图。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagebfe8bf6019d3e3953a4075b001f4853963e8.83cf76d2.png" alt=""/></p><p>显然这三个事务之间是存在环的，那么这三个事务就是不能串行化的。</p><p>这个异常现象中很有意思的一点是，虽然T1是一个只读事务，但如果没有T1的话，T2与T3不会形成环，依然是可串行化执行的。这里就为我们澄清了一点：我们直觉上认为的只读事务不会影响事务并发机制，其实是不对的。</p><h3 id="工程实现cockroachdb"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#工程实现cockroachdb"><span class="icon icon-link"></span></a>工程实现：CockroachDB</h3><p>RW反向依赖是一个非常特别的存在，而特别之处就在于传统的锁机制无法记录这种情况。因此在论文“<a target="_blank" rel="noopener noreferrer" href="http://vldb.org/pvldb/vol5/p1850_danrkports_vldb2012.pdf">Serializable Snapshot Isolation in PostgreSQL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中提出，增加一种锁SIREAD，用来记录快照隔离（SI）上所有执行过的读操作（Read），从而识别RW反向依赖。本质上，SIREAD并不是锁，只是一种标识。但这个方案面临的困境是，读操作涉及到的数据范围实在太大，跟踪标识带来的成本可能比S2PL还要高，也就无法达到最初的目标。</p><p>针对这个问题，CockroachDB做了一个关键设计，<strong>读时间戳缓存</strong>（Read Timestamp Cache），简称RTC。</p><p>基于RTC的新方案是这样的，当执行任何的读取操作时，操作的时间戳都会被记录在所访问节点的本地RTC中。当任何写操作访问这个节点时，都会以将要访问的Key为输入，向RTC查询最大的读时间戳（MRT），如果MRT大于这个写入操作的时间戳，那继续写入就会形成RW依赖。这时就必须终止并重启写入事务，让写入事务拿到一个更大的时间戳重新尝试。</p><p>具体来说，RTC是以Key的范围来组织读时间戳的。这样，当读取操作携带了谓词条件，比如where子句，对应的操作就是一个范围读取，会覆盖若干个Key，那么整个Key的范围也可以被记录在RTC中。这样处理的好处是，可以兼容一种特殊情况。</p><p>例如，事务T1第一次范围读取（Range Scan）数据表，where条件是“&gt;=1 and &lt;=5”，读取到1、2、5三个值，T1完成后，事务T2在该表插入了4，因为RTC记录的是范围区间[1,5]，所以4也可以被检测出存在RW依赖。这个地方，有点像MySQL间隙锁的原理。</p><p>RTC是一个大小有限的，采用LRU（Least Recently Used，最近最少使用）淘汰算法的缓存。当达到存储上限时，最老的时间戳会被抛弃。为了应对缓存超限的情况，会将RTC中出现过的所有Key上最早的那个读时间戳记录下来，作为低水位线（Low Water Mark）。如果一个写操作将要写的Key不在RTC中，则会返回这个低水位线。</p><h2 id="相对乐观"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#相对乐观"><span class="icon icon-link"></span></a>相对乐观</h2><p>到这里，你应该大概理解了SGT的运行机制，它和传统的S2PL一样属于悲观协议。但SGT没有锁的管理成本，所以性能比S2PL更好。</p><p>CockroachDB基于SGT理论进行工程化，使可串行化真正成为生产级可用的隔离级别。从整体并发控制机制看，CockroachDB和上一讲的TiDB一样，虽然在局部看是悲观协议，但因为不符合严格的VRW顺序，所以在全局来看仍是一个相对乐观的协议。</p><p>这种乐观协议同样存在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/282401">第13讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提到的问题，所以CockroachDB也在原有基础上进行了改良，通过增加全局的锁表（Lock Table），使用加锁的方式，先进行一轮全局有效性验证，确定无冲突的情况下，再使用单个节点的SGT。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>有关悲观协议的内容就聊到这里了，我们一起梳理下今天课程的重点。</p><ol><li>并发控制机制的划分方法很多，没有统一标准，我们使用了<a target="_blank" rel="noopener noreferrer" href="http://www.gbv.de/dms/weimar/toc/647210940_toc.pdf">Transactional Information Systems : Theory, Algorithms, and the Practice of Concurrency Control and Recovery<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提出的划分标准，分为悲观协议与乐观协议两种。这里的乐观协议是上一讲提到的狭义乐观协议，悲观协议又分为锁和非锁两大类，我们简单介绍了2PL这一个分支。</li><li>我们回顾了Percolator模型，按照S2PL的定义，Percoloatro本质就是S2PL，因此TiDB的乐观锁也属于S2PL。</li><li>S2PL是数据库并发控制的主流技术，但是锁管理复杂，在实现串行化隔离级别时开销太大。而后，我们讨论了非锁协议中的串行化图检测（SGT）。PostgreSQL最早提出了SGT的工程实现方式SSI。CockroachDB在此基础上又进行了优化，降低了SIREAD的开销，是生产级的可串行化隔离。</li><li>CockroachDB最初和TiDB一样都是局部采用悲观协议，而不做全局有效性验证，是广义的乐观协议。后来，CockroachDB同样也将乐观协议改为悲观协议，采用的方式是增加全局的锁表，进行全局有效性验证，而后再转入单个的SGT处理。</li></ol><p>今天的课程中，我们提到了串行化理论，只有当相关事务形成DAG图时，这些事务才是可串行化的。这个理论不仅适用于SGT，2PL的最终调度结果也同样是DAG图。在更大范围内，批量任务调度时DAG也同样被作为衡量标准，例如Spark。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagea298a2de442d44b6fd69c16e83a509c0a698.6cd56bb8.png" alt=""/></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>课程的最后，我们来看看今天的思考题。</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/280925">第11讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中我们提到了MVCC。有的数据库教材中将MVCC作为一种重要的并发控制技术，与乐观协议、悲观协议并列，但我们今天并没有单独提到它。所以，我的问题是，你觉得该如何理解MVCC与乐观协议、悲观协议的关系呢？</p><p>欢迎你在评论区留言和我一起讨论，我会在答疑篇回复这个问题。如果你身边的朋友也对悲观协议或者并发控制技术这个话题感兴趣，你也可以把今天这一讲分享给他，我们一起讨论。</p><h2 id="学习资料"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式数据库30讲/03.开发篇/06#学习资料"><span class="icon icon-link"></span></a>学习资料</h2><p>最早的SSI工程实现方案：<a target="_blank" rel="noopener noreferrer" href="http://vldb.org/pvldb/vol5/p1850_danrkports_vldb2012.pdf">Serializable Snapshot Isolation in PostgreSQL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>按照狭义乐观协议和其他悲观协议划分并发控制协议：<a target="_blank" rel="noopener noreferrer" href="http://www.gbv.de/dms/weimar/toc/647210940_toc.pdf">Transactional Information Systems : Theory, Algorithms, and the Practice of Concurrency Control and Recovery<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式数据库30讲/03.开发篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
