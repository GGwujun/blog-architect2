<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      17 | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？ - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式协议与算法实战/04.实战篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/01"><span>开篇词 | 想成为分布式高手？那就先把协议和算法烂熟于心吧</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02"><span>学习路径 | 分布式协议与算法你应该这么学</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇">02.理论篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/01"><span>01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/02"><span>加餐  | 拜占庭将军问题：如何基于签名消息实现作战计划的一致性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/03"><span>02 | CAP理论：分布式系统的PH试纸，用它来测酸碱度</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/04"><span>03 | ACID理论：CAP的酸，追求一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/05"><span>04 | BASE理论：CAP的碱，追求可用性</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇">03.协议和算法篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/01"><span>05 | Paxos算法（一）：如何在多个节点间确定某变量的值？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/02"><span>06 | Paxos算法（二）：Multi-Paxos不是一个算法，而是统称</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/03"><span>07 | Raft算法（一）：如何选举领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/04"><span>08 | Raft算法（二）：如何复制日志？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/05"><span>09 | Raft算法（三）：如何解决成员变更的问题？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/06"><span>10 | 一致哈希算法：如何分群，突破集群的“领导者”限制？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/07"><span>11 | Gossip协议：流言蜚语，原来也可以实现一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/08"><span>12 | Quorum NWR算法：想要灵活地自定义一致性，没问题！</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/09"><span>13 | PBFT算法：有人作恶，如何达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/10"><span>加餐 | PBFT算法：如何替换作恶的领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/11"><span>14 | PoW算法：有办法黑比特币吗？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/12"><span>15 | ZAB协议：如何实现操作的顺序性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/13"><span>加餐 | ZAB协议（一）：主节点崩溃了，怎么办？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14"><span>加餐 | ZAB协议（二）：如何从故障中恢复？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15"><span>加餐 | ZAB协议（三）：如何处理读写请求？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/16"><span>加餐 | MySQL XA是如何实现分布式事务的？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/17"><span>加餐 | TCC如何实现指令执行的原子性？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/01"><span>16 | InfluxDB企业版一致性实现剖析：他山之石，可以攻玉</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02"><span>17  | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/03"><span>18 | Hashicorp Raft（二）：如何以“集群节点”为中心使用API？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/04"><span>19 | 基于Raft的分布式KV系统开发实战（一）：如何设计架构？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/05"><span>20 | 基于Raft的分布式KV系统开发实战（二）：如何实现代码？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语">05.结束语</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/01"><span>结束语 | 静下心来，享受技术的乐趣</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/02"><span>结课测试 | 这些分布式协议与算法的知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/summary">分布式协议与算法实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Hashicorp Raft如何实现领导者选举？" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#hashicorp-raft如何实现领导者选举"><span>Hashicorp Raft如何实现领导者选举？</span></a></li><li title="数据结构" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#数据结构"><span>数据结构</span></a></li><li title="选举领导者" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#选举领导者"><span>选举领导者</span></a></li><li title="Hashicorp Raft如何复制日志？" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#hashicorp-raft如何复制日志"><span>Hashicorp Raft如何复制日志？</span></a></li><li title="数据结构" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#数据结构-1"><span>数据结构</span></a></li><li title="领导者复制日志" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#领导者复制日志"><span>领导者复制日志</span></a></li><li title="跟随者接收日志" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#跟随者接收日志"><span>跟随者接收日志</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#内容小结"><span>内容小结</span></a></li><li title="课堂思考" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#课堂思考"><span>课堂思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="17---hashicorp-raft一如何跨过理论和代码之间的鸿沟"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#17---hashicorp-raft一如何跨过理论和代码之间的鸿沟"><span class="icon icon-link"></span></a>17  | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？</h1><p>你好，我是韩健。</p><p>很多同学在开发系统的时候，都会有这样的感觉：明明自己看了很多资料，掌握了技术背后的原理，可在开发和调试的时候还是很吃力，这是为什么呢？</p><p>答案很简单，因为理论和实践本来就是两回事，实践不仅需要掌握API接口的用法，还需要理解API背后的代码实现。</p><p>所以，如果你在使用Raft开发分布式系统的时候，仅仅阅读Raft论文或者Raft实现的API手册，是远远不够的。你还要吃透API背后的代码实现，“不仅知其然，也要知其所以然”，这样才能“一切尽在掌握中”，从而开发实现能稳定运行的分布式系统。那么怎么做才能吃透Raft的代码实现呢？</p><p>要知道，任何Raft实现都承载了两个目标：实现Raft算法的原理，设计易用的API接口。所以，你不仅要从算法原理的角度理解代码实现，而且要从场景使用的角度理解API接口的用法。</p><p>而我会用两节课的时间，**从代码实现和接口使用两个角度，**带你循序渐进地掌握当前流行的一个Raft实现：<a target="_blank" rel="noopener noreferrer" href="https://github.com/hashicorp/raft">Hashicorp Raft<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（以最新稳定版v1.1.1为例）。希望你在这个过程中集中注意力，勾划重点，以便提高学习效率，吃透原理对应的技术实现，彻底掌握Raft算法的实战技巧。</p><p>本节课，我会从算法原理的角度，聊一聊Raft算法的核心功能（领导者选举和日志复制）在Hashicorp Raft中是如何实现的。（如果Raft算法的原理你已经忘得差不多了，那你可以先回顾下7～9讲，加深印象之后，再进入今天的学习。）</p><h2 id="hashicorp-raft如何实现领导者选举"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#hashicorp-raft如何实现领导者选举"><span class="icon icon-link"></span></a>Hashicorp Raft如何实现领导者选举？</h2><p>**在我看来，阅读源码的关键，在于找到代码的入口函数，**比如在Golang代码中，程序的入口函数一般为main()函数，那么领导者选举的入口函数是哪个呢？</p><p>我们知道，典型的领导者选举在本质上是节点状态的变更。具体到Hashicorp Raft源码中，领导者选举的入口函数run()，在raft.go中以一个单独的协程运行，来实现节点状态变迁，就像下面的样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (r *Raft) run() {</span></div><div class="token-line"><span class="token plain">            for {</span></div><div class="token-line"><span class="token plain">                    select {</span></div><div class="token-line"><span class="token plain">                    // 关闭节点</span></div><div class="token-line"><span class="token plain">                    case &lt;-r.shutdownCh:</span></div><div class="token-line"><span class="token plain">                            r.setLeader(&quot;&quot;)</span></div><div class="token-line"><span class="token plain">                            return</span></div><div class="token-line"><span class="token plain">                    default:</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    switch r.getState() {</span></div><div class="token-line"><span class="token plain">                    // 跟随者</span></div><div class="token-line"><span class="token plain">                    case Follower:</span></div><div class="token-line"><span class="token plain">                            r.runFollower()</span></div><div class="token-line"><span class="token plain">                    // 候选人</span></div><div class="token-line"><span class="token plain">                    case Candidate:</span></div><div class="token-line"><span class="token plain">                            r.runCandidate()</span></div><div class="token-line"><span class="token plain">                    // 领导者</span></div><div class="token-line"><span class="token plain">                    case Leader:</span></div><div class="token-line"><span class="token plain">                            r.runLeader()</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上面这段代码中，你能看到，Follower（跟随者）、Candidate（候选人）、Leader（领导者）三个节点状态对应的功能，都被抽象成一个函数，分别是runFollower()、runCandidate()和runLeader()。</p><h3 id="数据结构"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#数据结构"><span class="icon icon-link"></span></a>数据结构</h3><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/204472">07讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们先学习了节点状态，不过主要侧重理解节点状态的功能作用（比如说，跟随者相当于普通群众，领导者是霸道总裁），并没有关注它在实际代码中是如何实现的，所以我们先来看看在Hashicorp Raft中是如何实现节点状态的。</p><p>节点状态相关的数据结构和函数，是在state.go中实现的。跟随者、候选人和领导者的3个状态，是由RaftState定义的，一个无符号32位的只读整型数值（uint32）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type RaftState uint32</span></div><div class="token-line"><span class="token plain">    const (</span></div><div class="token-line"><span class="token plain">            // 跟随者</span></div><div class="token-line"><span class="token plain">            Follower RaftState = iota</span></div><div class="token-line"><span class="token plain">            // 候选人</span></div><div class="token-line"><span class="token plain">            Candidate</span></div><div class="token-line"><span class="token plain">            // 领导者</span></div><div class="token-line"><span class="token plain">            Leader</span></div><div class="token-line"><span class="token plain">            // 关闭状态</span></div><div class="token-line"><span class="token plain">            Shutdown</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>需要注意的是，**也存在一些需要使用字符串格式的节点状态的场景（比如日志输出），**这时你可以使用RaftState.String()函数。</p><p>你应该还记得，每个节点都有属于本节点的信息（比如任期编号），那么在代码中如何实现这些信息呢？这就要说到raftState数据结构了。</p><p>raftState属于结构体类型，是表示节点信息的一个大数据结构，里面包含了只属于本节点的信息，比如节点的当前任期编号、最新提交的日志项的索引值、存储中最新日志项的索引值和任期编号、当前节点的状态等，就像下面的样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type raftState struct {</span></div><div class="token-line"><span class="token plain">            // 当前任期编号</span></div><div class="token-line"><span class="token plain">            currentTerm uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 最大被提交的日志项的索引值</span></div><div class="token-line"><span class="token plain">            commitIndex uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 最新被应用到状态机的日志项的索引值</span></div><div class="token-line"><span class="token plain">            lastApplied uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 存储中最新的日志项的索引值和任期编号  </span></div><div class="token-line"><span class="token plain">            lastLogIndex uint64</span></div><div class="token-line"><span class="token plain">            lastLogTerm  uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 当前节点的状态</span></div><div class="token-line"><span class="token plain">            state RaftState</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>节点状态与节点信息的定义就是这么简单，这里我就不多说了。而在分布式系统中要实现领导者选举，更重要的一层内容是实现RPC消息，因为领导者选举的过程，就是一个RPC通讯的过程。</p><p>在理论篇中我说过，Raft算法中支持多种RPC消息（比如请求投票RPC消息、日志复制RPC消息）。所以接下来我们看一看，在Hashicorp Raft中又是怎样实现RPC消息的。又因为在一个RPC消息中，最重要的部分就是消息的内容，所以我们先来看一看RPC消息对应的数据结构。</p><p>RPC消息相关的数据结构是在commands.go中定义的，比如，日志复制RPC的请求消息，对应的数据结构为AppendEntriesRequest。而AppendEntriesRequest是一个结构体类型，里面包含了Raft算法论文中约定的字段，比如以下这些内容。</p><ul><li>Term：当前的任期编号。</li><li>PrevLogEntry：表示当前要复制的日志项，前面一条日志项的索引值。</li><li>PrevLogTerm：表示当前要复制的日志项，前面一条日志项的任期编号。</li><li>Entries：新日志项。</li></ul><p>具体的结构信息，就像下面的样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type AppendEntriesRequest struct {</span></div><div class="token-line"><span class="token plain">            // 当前的任期编号，和领导者信息（包括服务器ID和地址信息）</span></div><div class="token-line"><span class="token plain">            Term   uint64</span></div><div class="token-line"><span class="token plain">            Leader []byte</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 当前要复制的日志项，前面一条日志项的索引值和任期编号</span></div><div class="token-line"><span class="token plain">            PrevLogEntry uint64</span></div><div class="token-line"><span class="token plain">            PrevLogTerm  uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 新日志项</span></div><div class="token-line"><span class="token plain">            Entries []*Log</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 领导者节点上的已提交的日志项的最大索引值</span></div><div class="token-line"><span class="token plain">            LeaderCommitIndex uint64</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我建议你可以采用上面的思路，对照着算法原理去学习其他RPC消息的实现，这样一来你就能掌握独立学习的能力了。其他RPC消息的数据结构我就不一一描述了（如果你遇到问题，可以在留言区留言）。</p><p>现在，你已经了解了节点状态和RPC消息的格式，掌握了这些基础知识后，我们继续下一步，看看在Hashicorp Raft中是如何进行领导者选举的。</p><h3 id="选举领导者"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#选举领导者"><span class="icon icon-link"></span></a>选举领导者</h3><p>首先，在初始状态下，集群中所有的节点都处于跟随者状态，函数runFollower()运行，大致的执行步骤，就像下图的样子：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage281528753c692659fa4017c6a943c3d05b15.d5217822.jpg" alt=""/></p><p>我带你走一遍这五个步骤，便于你加深印象。</p><ol><li>根据配置中的心跳超时时长，调用randomTimeout()函数来获取一个随机值，用以设置心跳超时时间间隔。</li><li>进入到for循环中，通过select实现多路IO复用，周期性地获取消息和处理。如果步骤1中设置的心跳超时时间间隔发生了超时，执行步骤3。</li><li>如果等待心跳信息未超时，执行步骤4，如果等待心跳信息超时，执行步骤5。</li><li>执行continue语句，开始一次新的for循环。</li><li>设置节点状态为候选人，并退出runFollower()函数。</li></ol><p>当节点推举自己为候选人之后，函数runCandidate()执行，大致的执行步骤，如图所示：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage984d989efd10cdff6825356b8a4310e5704d.d9da3dd4.jpg" alt=""/></p><p>同样的，我们走一遍这个过程，加深一下印象。</p><ol><li>首先调用electSelf()发起选举，给自己投一张选票，并向其他节点发送请求投票RPC消息，请求他们选举自己为领导者。然后调用randomTimeout()函数，获取一个随机值，设置选举超时时间。</li><li>进入到for循环中，通过select实现多路IO复用，周期性地获取消息和处理。如果发生了选举超时，执行步骤3，如果得到了投票信息，执行步骤4。</li><li>发现了选举超时，退出runCandidate()函数，然后再重新执行runCandidate()函数，发起新一轮的选举。</li><li>如果候选人在指定时间内赢得了大多数选票，那么候选人将当选为领导者，调用setState()函数，将自己的状态变更为领导者，并退出runCandidate()函数。</li></ol><p>当节点当选为领导者后，函数runLeader()就执行了：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage173e17619089bc683d8a1a2bd20bf678503e.77c7c516.jpg" alt=""/></p><p>整个过程，主要有4个步骤。</p><ol><li>调用startStopReplication()，执行日志复制功能。</li><li>然后启动新的协程，调用replicate()函数，执行日志复制功能。</li><li>接着在replicate()函数中，启动一个新的协程，调用heartbeat()函数，执行心跳功能。</li><li>在heartbeat()函数中，周期性地发送心跳信息，通知其他节点，我是领导者，我还活着，不需要你们发起新的选举。</li></ol><p>其实，在Hashicorp Raft中实现领导者选举并不难，你只要充分理解上述步骤，并记住，领导者选举本质上是节点状态变迁，跟随者、候选人、领导者对应的功能函数分别为runFollower()、runCandidate()、runLeader()，就可以了。</p><h2 id="hashicorp-raft如何复制日志"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#hashicorp-raft如何复制日志"><span class="icon icon-link"></span></a>Hashicorp Raft如何复制日志？</h2><p>学习<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/205784">08<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>讲之后，你应该知道了日志复制的重要性，因为Raft是基于强领导者模型和日志复制，最终实现强一致性的。那么你该如何学习日志复制的代码实现呢？和学习“如何实现领导者选举”一样，你需要先了解了日志相关的数据结构，阅读日志复制相关的代码。</p><p>学习了理论篇后，你应该还记得日志复制是由领导者发起的，跟随者来接收的。可能有同学已经想到了，领导者复制日志和跟随者接收日志的入口函数，应该分别在runLeader()和runFollower()函数中调用的。赞！理解正确！</p><ul><li>领导者复制日志的入口函数为startStopReplication()，在runLeader()中，以r.startStopReplication()形式被调用，作为一个单独协程运行。</li><li>跟随者接收日志的入口函数为processRPC()，在runFollower()中以r.processRPC(rpc)形式被调用，来处理日志复制RPC消息。</li></ul><p>不过，在分析日志复制的代码实现之前，咱们先来聊聊日志相关的数据结构，便于你更好地理解代码实现。</p><h3 id="数据结构-1"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#数据结构-1"><span class="icon icon-link"></span></a>数据结构</h3><p>08讲中我提到过，一条日志项主要包含了3种信息，分别是指令、索引值、任期编号，而在Hashicorp Raft实现中，日志对应的数据结构和函数接口是在log.go中实现的，其中，日志项对应的数据结构是结构体类型的，就像下面的样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Log struct {</span></div><div class="token-line"><span class="token plain">            // 索引值</span></div><div class="token-line"><span class="token plain">            Index uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 任期编号</span></div><div class="token-line"><span class="token plain">            Term uint64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 日志项类别</span></div><div class="token-line"><span class="token plain">            Type LogType</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 指令</span></div><div class="token-line"><span class="token plain">            Data []byte</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 扩展信息</span></div><div class="token-line"><span class="token plain">            Extensions []byte</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我强调一下，与协议中的定义不同，日志项对应的数据结构中，包含了LogType和Extensions两个额外的字段：</p><ul><li>LogType可用于标识不同用途的日志项，比如，使用LogCommand标识指令对应的日志项，使用LogConfiguration表示成员变更配置对应的日志项。</li><li>Extensions可用于在指定日志项中存储一些额外的信息。<strong>这个字段使用的比较少，在调试等场景中可能会用到，你知道有这么个字段就可以了。</strong><br/>说完日志复制对应的数据结构，我们分步骤看一下，在Hashicorp Raft中是如何实现日志复制的。</li></ul><h3 id="领导者复制日志"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#领导者复制日志"><span class="icon icon-link"></span></a>领导者复制日志</h3><p>日志复制是由领导者发起，在runLeader()函数中执行的，主要有这样几个步骤。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagec263c2aa9f2c31571e8cdc4dbe13ef210663.0d5552e4.jpg" alt=""/></p><ol><li>在 runLeader()函数中，调用startStopReplication()函数，执行日志复制功能。</li><li>启动一个新协程，调用replicate()函数，执行日志复制相关的功能。</li><li>在replicate()函数中，调用replicateTo()函数，执行步骤4，如果开启了流水线复制模式，执行步骤5。</li><li>在replicateTo()函数中，进行日志复制和日志一致性检测，如果日志复制成功，则设置s.allowPipeline = true，开启流水线复制模式。</li><li>调用pipelineReplicate()函数，采用更高效的流水线方式，进行日志复制。</li></ol><p>在这里我强调一下，在什么条件下开启了流水线复制模式，很多同学可能会在这一块儿产生困惑，因为代码逻辑上有点儿绕。**你可以这么理解，是在不需要进行日志一致性检测，复制功能已正常运行的时候，开启了流水线复制模式，**目标是在环境正常的情况下，提升日志复制性能，如果在日志复制过程中出错了，就进入RPC复制模式，继续调用replicateTo()函数，进行日志复制。</p><h3 id="跟随者接收日志"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#跟随者接收日志"><span class="icon icon-link"></span></a>跟随者接收日志</h3><p>领导者复制完日志后，跟随者会接收日志并开始处理日志。跟随者接收和处理日志，是在runFollower()函数中执行的，主要有这样几个步骤。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage999699458f26ef6387bc8b20b16380d46896.cdfabc0d.jpg" alt=""/></p><ol><li>在runFollower()函数中，调用processRPC()函数，处理接收到的RPC消息。</li><li>在processRPC()函数中，调用appendEntries()函数，处理接收到的日志复制RPC请求。</li><li>appendEntries()函数，是跟随者处理日志的核心函数。在步骤3.1中，比较日志一致性；在步骤3.2中，将新日志项存放在本地；在步骤3.3中，根据领导者最新提交的日志项索引值，来计算当前需要被应用的日志项，并应用到本地状态机。</li></ol><p>讲到这儿，你应该可以了解日志复制的代码实现了吧。关于更多的Raft原理的代码实现，你可以继续阅读源码来学习，如果在学习过程中有疑问，欢迎给我留言。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>本节课我主要带你了解了如何从算法原理的角度理解Hashicorp Raft实现，有几个重点我想强调一下：</p><ol><li><p>跟随者、候选人、领导者3种节点状态都有分别对应的功能函数，当需要查看各节点状态相关的功能实现时（比如，跟随者如何接收和处理日志），都可以将对应的函数作为入口函数，来阅读代码和研究功能实现。</p></li><li><p>raft.go是Hashicorp Raft的核心代码文件，大部分的核心功能都是在这个文件中实现的，平时可以多研究这个文件中的代码，直到彻底吃透，掌握。</p></li><li><p>在Hashicorp Raft中，支持两种节点间通讯机制，内存型和TCP协议型，其中，内存型通讯机制，主要用于测试，2种通讯机制的代码实现，分别在文件inmem_transport.go和tcp_transport.go中。</p></li><li><p>Hashicorp Raft实现，是常用的Golang版Raft算法的实现，被众多流行软件使用，如Consul、InfluxDB、IPFS等，相信你对它并不陌生。其他的实现还有<a target="_blank" rel="noopener noreferrer" href="https://github.com/goraft/raft">Go-Raft<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/logcabin/logcabin">LogCabin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/willemt/raft">Willemt-Raft<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等，不过我建议你在后续开发分布式系统时，优先考虑Hashicorp Raft，因为Hashicorp Raft实现，功能完善、代码简洁高效、流行度高，可用性和稳定性被充分打磨。</p></li></ol><p>最后，关于如何高效地阅读源码，我还想多说一说。在我看来，高效阅读源码的关键在于抓住重点，要有“底线”，不要芝麻和西瓜一把抓，什么都想要，最终陷入到枝节琐碎的细节中出不来。什么是重点呢？我认为重点是数据结构和关键的代码执行流程，比如在Hashicorp Raft源码中，日志项对应的数据结构、RPC消息对应的数据结构、选举领导者的流程、日志复制的流程等，这些就是重点。</p><p>有的同学可能还有疑问：在阅读源码的时候，如果遇到不是很明白的代码，该怎么办呢？我建议你可以通过打印日志或GDB单步调试的方式，查看上下文中的变量的内容、代码执行逻辑等，帮助理解。</p><h2 id="课堂思考"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/04.实战篇/02#课堂思考"><span class="icon icon-link"></span></a>课堂思考</h2><p>在Hashicorp Raft实现中，我讲了如何实现选举领导者，以及如何复制日志等，那么在Hashicorp Raft中，网络通讯是如何实现的呢？欢迎在留言区分享你的看法，与我一同讨论。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式协议与算法实战/04.实战篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
