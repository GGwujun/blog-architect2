<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>加餐 | ZAB协议（二）：如何从故障中恢复？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式协议与算法实战/03.协议和算法篇/14" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/01"><span>开篇词 | 想成为分布式高手？那就先把协议和算法烂熟于心吧</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02"><span>学习路径 | 分布式协议与算法你应该这么学</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇">02.理论篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/01"><span>01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/02"><span>加餐  | 拜占庭将军问题：如何基于签名消息实现作战计划的一致性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/03"><span>02 | CAP理论：分布式系统的PH试纸，用它来测酸碱度</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/04"><span>03 | ACID理论：CAP的酸，追求一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/05"><span>04 | BASE理论：CAP的碱，追求可用性</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇">03.协议和算法篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/01"><span>05 | Paxos算法（一）：如何在多个节点间确定某变量的值？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/02"><span>06 | Paxos算法（二）：Multi-Paxos不是一个算法，而是统称</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/03"><span>07 | Raft算法（一）：如何选举领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/04"><span>08 | Raft算法（二）：如何复制日志？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/05"><span>09 | Raft算法（三）：如何解决成员变更的问题？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/06"><span>10 | 一致哈希算法：如何分群，突破集群的“领导者”限制？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/07"><span>11 | Gossip协议：流言蜚语，原来也可以实现一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/08"><span>12 | Quorum NWR算法：想要灵活地自定义一致性，没问题！</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/09"><span>13 | PBFT算法：有人作恶，如何达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/10"><span>加餐 | PBFT算法：如何替换作恶的领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/11"><span>14 | PoW算法：有办法黑比特币吗？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/12"><span>15 | ZAB协议：如何实现操作的顺序性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/13"><span>加餐 | ZAB协议（一）：主节点崩溃了，怎么办？</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14"><span>加餐 | ZAB协议（二）：如何从故障中恢复？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15"><span>加餐 | ZAB协议（三）：如何处理读写请求？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/16"><span>加餐 | MySQL XA是如何实现分布式事务的？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/17"><span>加餐 | TCC如何实现指令执行的原子性？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/01"><span>16 | InfluxDB企业版一致性实现剖析：他山之石，可以攻玉</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02"><span>17  | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/03"><span>18 | Hashicorp Raft（二）：如何以“集群节点”为中心使用API？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/04"><span>19 | 基于Raft的分布式KV系统开发实战（一）：如何设计架构？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/05"><span>20 | 基于Raft的分布式KV系统开发实战（二）：如何实现代码？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语">05.结束语</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/01"><span>结束语 | 静下心来，享受技术的乐趣</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/02"><span>结课测试 | 这些分布式协议与算法的知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/summary">分布式协议与算法实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="ZAB集群怎么从故障中恢复过来？" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#zab集群怎么从故障中恢复过来"><span>ZAB集群怎么从故障中恢复过来？</span></a></li><li title="如何确立领导关系？" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#如何确立领导关系"><span>如何确立领导关系？</span></a></li><li title="如何处理冲突数据？" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#如何处理冲突数据"><span>如何处理冲突数据？</span></a></li><li title="ZooKeeper如何恢复故障？" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#zookeeper如何恢复故障"><span>ZooKeeper如何恢复故障？</span></a></li><li title="成员发现" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#成员发现"><span>成员发现</span></a></li><li title="数据同步" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#数据同步"><span>数据同步</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#内容小结"><span>内容小结</span></a></li><li title="课堂思考" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#课堂思考"><span>课堂思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="加餐--zab协议二如何从故障中恢复"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#加餐--zab协议二如何从故障中恢复"><span class="icon icon-link"></span></a>加餐 | ZAB协议（二）：如何从故障中恢复？</h1><p>你好，我是韩健。</p><p>我们上一讲提到了ZAB的领导者选举，在我看来，它只是选举了一个适合当领导者的节点，然后把这个节点的状态设置成LEADING状态。此时，这个节点还不能作为主节点处理写请求，也不能使用领导职能（比如，它没办法阻止其他“领导者”广播提案）。也就是说，集群还没有从故障中恢复过来，而成员发现和数据同步会解决这个问题。</p><p>总的来说，成员发现和数据同步不仅让新领导者正式成为领导者，确立了它的领导关系，还解决了各副本的数据冲突，实现了数据副本的一致性。这样一来，集群就能正常处理写请求了。在这句话里：</p><ul><li>确立领导关系，也就是在成员发现（DISCOVERY）阶段，领导者和大多数跟随者建立连接，并再次确认各节点对自己当选领导者没有异议，确立自己的领导关系；</li><li>处理冲突数据，也就是在数据同步（SYNCHRONIZATION）阶段，领导者以自己的数据为准，解决各节点数据副本的不一致。</li></ul><p>对你来说，理解这两点，可以更好地理解ZooKeeper怎么恢复故障，以及当主节点崩溃了，哪些数据会丢失，哪些不会，以及背后的原因。也就是说，你能更加深刻地理解ZooKeeper的节点故障容错能力。</p><p>那么说了这么多，集群具体是怎么从故障中恢复过来的呢？带着这个问题，我们进入今天的学习。</p><h2 id="zab集群怎么从故障中恢复过来"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#zab集群怎么从故障中恢复过来"><span class="icon icon-link"></span></a>ZAB集群怎么从故障中恢复过来？</h2><p>如果我们想把ZAB集群恢复到正常状态，那么新领导者就要确立自己的领导关系，成为唯一有效的领导者，然后作为主节点“领导”各备份节点一起处理读写请求。</p><h3 id="如何确立领导关系"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#如何确立领导关系"><span class="icon icon-link"></span></a>如何确立领导关系？</h3><p>那么通过开篇，你可以知道，选举出的领导者，是在成员发现阶段确立领导关系的。</p><p>在当选后，领导者会递增自己的任期编号，并基于任期编号值的大小，来和跟随者协商，最终建立领导关系。<strong>具体说的话，就是跟随者会选择任期编号值最大的节点，作为自己的领导者，而被大多数节点认同的领导者，将成为真正的领导者。</strong></p><p>我举个例子，具体帮你理解一下。</p><p>假设一个ZooKeeper集群，由节点A、B、C组成。其中，领导者A已经宕机，C是新选出来的领导者，B是新的跟随者（为了方便演示，假设B、C已提交提案的事务标识符最大值分别是&lt;1, 10&gt;和&lt;1, 11&gt;，其中1是任期编号，10、11是事务标识符中的计数器值，A宕机前的任期编号也是1）。那么B、C如何协商建立领导关系呢？</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage9a349a31fd8f5d888abfb014b07408c4be34.2ae5f853.jpg" alt="" title="图1"/></p><p>首先，B、C会把自己的ZAB状态设置为成员发现（DISCOVERY），这就表明，选举（ELECTION）阶段结束了，进入了下一个阶段：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage5c8c5c933b8033238c2f58ea19c39bf12f8c.54dff637.jpg" alt="" title="图2"/></p><p>在这里，我想补充一下，ZAB定义了4种状态，来标识节点的运行状态。</p><ul><li>ELECTION（选举状态）：表明节点在进行领导者选举；</li><li>DISCOVERY（成员发现状态）：表明节点在协商沟通领导者的合法性；</li><li>SYNCHRONIZATION（数据同步状态）：表明集群的各节点以领导者的数据为准，修复数据副本的一致性；</li><li>BROADCAST（广播状态）：表明集群各节点在正常处理写请求。</li></ul><p>关于这4种状态，你知道它们是做什么的就可以了。我就强调一点，<strong>只有当集群大多数节点处于广播状态的时候，集群才能提交提案。</strong></p><p>接下来，B会主动联系C，发送给它包含自己接收过的领导者任期编号最大值（也就是前领导者A的任期编号，1）的FOLLOWINFO消息。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagef556f5209e12171cffbe1ed4a9b4835eca56.73d23aba.jpg" alt="" title="图3"/></p><p>当C接收来自B的信息时，它会将包含自己事务标识符最大值的LEADINFO消息发给跟随者。</p><p>你要注意，领导者进入到成员发现阶段后，会对任期编号加1，创建新的任期编号，然后基于新任期编号，创建新的事务标识符（也就是&lt;2, 0&gt;）。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagef515f54d28ba395fa1fd8bfa1f95e2574815.7db19315.jpg" alt="" title="图4"/></p><p>当接收到领导者的响应后，跟随者会判断领导者的任期编号是否最新，如果不是，就发起新的选举；如果是，跟随者返回ACKEPOCH消息给领导者。在这里，C的任期编号（也就是2）大于B接受过的其他领导任期编号（也就是旧领导者A的任期编号，1），所以B返回确认响应给C，并设置ZAB状态为数据同步。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageef79ef46c226ad137738100c9764dff96879.f0260440.jpg" alt="" title="图5"/></p><p>最后，当领导者接收到来自大多数节点的ACKEPOCH消息时，就设置ZAB状态为数据同步。在这里，C接收到了B的消息，再加上C自己，就是大多数了，所以，在接收到来自B的消息后，C设置ZAB状态为数据同步。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage0f410f7569a56088a5df3383b64313d55541.e4e67a89.jpg" alt="" title="图6"/></p><p>**现在，ZAB在成员发现阶段确立了领导者的领导关系，之后领导者就可以行使领导职能了。**而这时它首先要解决的就是数据冲突，实现各节点数据的一致性，那么它是怎么做的呢？</p><h3 id="如何处理冲突数据"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#如何处理冲突数据"><span class="icon icon-link"></span></a>如何处理冲突数据？</h3><p>当进入到数据同步状态后，领导者会根据跟随者的事务标识符最大值，判断以哪种方式处理不一致数据（有DIFF、TRUNC、SNAP这3种方式，后面我会具体说一说）。</p><p>因为C已提交提案的事务标识符最大值（也就是&lt;1, 11&gt;）大于B已提交提案的事务标识符最大值（也就是&lt;1, 10&gt;），所以C会用DIFF的方式修复数据副本的不一致，并返回差异数据（也就是事务标识符为&lt;1, 11&gt;的提案）和NEWLEADER消息给B。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimageaa7aaa434b6ef27b7e702857d796ae53257a.4ac99899.jpg" alt="" title="图7"/></p><p>**在这里，我想强调一点：B已提交提案的最大值，也是它最新提案的最大值。**因为在ZooKeeper实现中，节点退出跟随者状态时（也就是在进入选举前），所有未提交的提案都会被提交。这是ZooKeeper的设计，你知道有这么个事就可以了。</p><p>然后，B修复不一致数据，返回NEWLEADER消息的确认响应给领导者。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage870687308ab8b9ba6eabc9217d0eeba03d06.ac04f254.jpg" alt="" title="图8"/></p><p>接着，当领导者接收到来自大多数节点的NEWLEADER消息的确认响应，将设置ZAB状态为广播。在这里，C接收到B的确认响应，加上C自己，就是大多数确认了。所以，在接收到来自B的确认响应后，C设置自己的ZAB状态为广播，并发送UPTODATE消息给所有跟随者，通知它们数据同步已经完成了。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagea526a53e5ea1bbc85f2d80e766bd85382d26.49c4873f.jpg" alt="" title="图9"/></p><p>最后当B接收到UPTODATE消息时，它就知道数据同步完成了，就设置ZAB状态为广播。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage426542d2162cb833a3b50fd44ba00556ed65.7fa5e606.jpg" alt="" title="图10"/></p><p>这个时候，集群就可以正常处理写请求了。</p><p>现在，我已经讲完了故障恢复的原理，那接下来，我们就来看一看ZooKeeper到底是怎么实现的吧。</p><h2 id="zookeeper如何恢复故障"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#zookeeper如何恢复故障"><span class="icon icon-link"></span></a>ZooKeeper如何恢复故障？</h2><h3 id="成员发现"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#成员发现"><span class="icon icon-link"></span></a>成员发现</h3><p>成员发现是通过跟随者和领导者交互来完成的，<strong>目标是确保大多数节点对领导者的领导关系没有异议，也就是确立领导者的领导地位。</strong></p><p>大概的实现流程，就像下面这样：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage90c6900afb50caffdee9d0fa46cc121893c6.697c80fe.jpg" alt="" title="图11"/></p><p>为帮你更好地理解这个流程，我们来走一遍核心代码的流程，加深下印象。</p><p>第一步，领导者选举结束，节点进入跟随者状态或者领导者状态后，它们会分别设置ZAB状态为成员发现。具体来说就是：</p><ul><li>跟随者会进入到Follower.followLeader()函数中执行，设置ZAB状态为成员发现。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">self.setZabState(QuorumPeer.ZabState.DISCOVERY);</span></div></pre></div><ul><li>领导者会进入到Leader.lead()函数中执行，并设置ZAB状态为成员发现。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">self.setZabState(QuorumPeer.ZabState.DISCOVERY);</span></div></pre></div><p>第二，跟随者会主动联系领导者，发送自己已接受的领导者任期编号最大值（也就是acceptedEpoch）的FOLLOWINFO消息给领导者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 跟领导者建立网络连接</span></div><div class="token-line"><span class="token plain">    connectToLeader(leaderServer.addr, leaderServer.hostname);</span></div><div class="token-line"><span class="token plain">    connectionTime = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">    // 向领导者报道，并获取领导者的事务标识符最大值</span></div><div class="token-line"><span class="token plain">    long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span></div></pre></div><p>第三，接收到来自跟随者的FOLLOWINFO消息后，在LearnerHandler.run()函数中，领导者将创建包含自己事务标识符最大值的LEADINFO消息，并响应给跟随者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建LEADINFO消息</span></div><div class="token-line"><span class="token plain">    QuorumPacket newEpochPacket = new </span></div><div class="token-line"><span class="token plain">    QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);</span></div><div class="token-line"><span class="token plain">    // 发送LEADINFO消息给跟随者</span></div><div class="token-line"><span class="token plain">    oa.writeRecord(newEpochPacket, &quot;packet&quot;);</span></div></pre></div><p>第四，接收到来自领导者的LEADINFO消息后，跟随者会基于领导者的任期编号，判断领导者是否合法，如果领导者不合法，跟随者发起新的选举，如果领导者合法，响应ACKEPOCH消息给领导者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建ACKEPOCH消息，包含已提交提案的事务标识符最大值</span></div><div class="token-line"><span class="token plain">    QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);</span></div><div class="token-line"><span class="token plain">    // 响应ACKEPOCH消息给领导者</span></div><div class="token-line"><span class="token plain">    writePacket(ackNewEpoch, true);</span></div></pre></div><p>第五，跟随者设置ZAB状态为数据同步。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);</span></div></pre></div><p>第六，需要你注意的是，在LearnerHandler.run()函数中（以及Leader.lead()函数），领导者会调用waitForEpochAck()函数，来阻塞和等待来自大多数节点的ACKEPOCH消息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());</span></div><div class="token-line"><span class="token plain">    learnerMaster.waitForEpochAck(this.getSid(), ss);</span></div></pre></div><p>第七，当领导者接收到来自大多数节点的ACKEPOCH消息后，在Leader.lead()函数中，领导者将设置ZAB状态为数据同步。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);</span></div></pre></div><p>这样，ZooKeeper就实现了成员发现，各节点就领导者的领导关系达成了共识。</p><p>当跟随者和领导者设置ZAB状态为数据同步，它们也就是进入了数据同步阶段，那在ZooKeeper中数据同步是如何实现的呢？</p><h3 id="数据同步"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#数据同步"><span class="icon icon-link"></span></a>数据同步</h3><p>数据同步也是通过跟随者和领导者交互来完成的，目标是确保跟随者节点上的数据与领导者节点上数据是一致的。大概的实现流程，如图所示：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage6e446ea74f1a56a9fd0f39b82b25d2814c44.cba9f3d9.jpg" alt="" title="图12"/></p><p>为了方便你理解，咱们一起走一遍核心代码的流程，加深下印象。</p><p>第一，在LearnerHandler.run()函数中，领导者调用syncFollower()函数，根据跟随者的事务标识符值最大值，判断用哪种方式处理不一致数据，把已经提交提案和未提交提案都同步给跟随者：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">peerLastZxid = ss.getLastZxid();</span></div><div class="token-line"><span class="token plain">    boolean needSnap = syncFollower(peerLastZxid, learnerMaster);</span></div></pre></div><p>在这里，需要你了解领导者向跟随者同步数据的三种方式（TRUNC、DIFF、SNAP），它们是什么含义呢？要想了解这部分内容，你首先要了解一下syncFollower()中，3个关键变量的含义。</p><ul><li>peerLastZxid：跟随者节点上，提案的事务标识符最大值。</li><li>maxCommittedLog、minCommittedLog：领导者节点内存队列中，已提交提案的事务标识符最大值和最小值。需要你注意的是，maxCommittedLog、minCommittedLog与ZooKeeper的设计有关。在ZooKeeper中，为了更高效地复制提案到跟随者上，领导者会将一定数量（默认值为500）的已提交提案放在内存队列里，而maxCommittedLog、minCommittedLog分别标识的是内存队列中，已提交提案的事务标识符最大值和最小值。</li></ul><p>说完3个变量的含义，我来说说3种同步方式。</p><ul><li><p>TRUNC：当peerLastZxid大于maxCommittedLog时，领导者会通知跟随者丢弃超出的那部分提案。比如，如果跟随者的peerLastZxid为11，领导者的maxCommittedLog为10，那么领导者将通知跟随者丢弃事务标识符值为11的提案。</p></li><li><p>DIFF：当peerLastZxid小于maxCommittedLog，但peerLastZxid大于minCommittedLog时，领导者会同步给跟随者缺失的已提交的提案，比如，如果跟随者的peerLastZxid为9，领导者的maxCommittedLog为10，minCommittedLog为9，那么领导者将同步事务标识符值为10的提案，给跟随者。</p></li><li><p>SNAP：当peerLastZxid小于minCommittedLog时，也就是说，跟随者缺失的提案比较多，那么，领导者同步快照数据给跟随者，并直接覆盖跟随者本地的数据。</p></li></ul><p>在这里，我想补充一下，领导者先就已提交提案和跟随者达成一致，然后调用learnerMaster.startForwarding()，将未提交提案（如果有的话）也缓存在发送队列（queuedPackets），并最终复制给跟随者节点。也就是说，<strong>领导者以自己的数据为准，实现各节点数据副本的一致的。</strong></p><p>需要你注意的是，在syncFolower()中，领导者只是将需要发送的差异数据缓存在发送队列（queuedPackets），这个时候还没有发送。</p><p>第二，在LearnerHandler.run()函数中，领导者创建NEWLEADER消息，并缓存在发送队列中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建NEWLEADER消息</span></div><div class="token-line"><span class="token plain">    QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);</span></div><div class="token-line"><span class="token plain">    // 缓存NEWLEADER消息到发送队列中</span></div><div class="token-line"><span class="token plain">    queuedPackets.add(newLeaderQP);</span></div></pre></div><p>第三，在LearnerHandler.run()函数中，领导者调用startSendingPackets()函数，启动一个新线程，并将缓存的数据发送给跟随者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 发送缓存队列中的数据</span></div><div class="token-line"><span class="token plain">    startSendingPackets();</span></div></pre></div><p>第四，跟随者调用syncWithLeader()函数，处理来自领导者的数据同步。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 处理数据同步</span></div><div class="token-line"><span class="token plain">    syncWithLeader(newEpochZxid);</span></div></pre></div><p>第五，在syncWithLeader()函数，跟随者接收到来自领导者的NEWLEADER消息后，返回确认响应给领导者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);</span></div></pre></div><p>第六，在LearnerHandler.run()函数中（以及Leader.lead()函数），领导者等待来自大多数节点的NEWLEADER消息的响应。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());</span></div></pre></div><p>第七，当领导者接收到来自大多数节点的NEWLEADER消息的响应时，在Leader.lead()函数中，领导者设置ZAB状态为广播状态。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">self.setZabState(QuorumPeer.ZabState.BROADCAST);</span></div></pre></div><p>并在LearnerHandler.run()中发送UPTODATE消息给所有跟随者，通知它们数据同步已完成了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));</span></div></pre></div><p>第八，当跟随者接收到UPTODATE消息时，就知道自己修复完数据不一致了，可以处理写请求了，就设置ZAB状态为广播。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 数据同步完成后，也就是可以正常处理来自领导者的广播消息了，设置ZAB状态为广播</span></div><div class="token-line"><span class="token plain">    self.setZabState(QuorumPeer.ZabState.BROADCAST);</span></div></pre></div><p>你看，这样就确保各节点数据的一致了，接下来，就可以以领导者为主，向其他节点广播消息了。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>本节课我主要带你了解了ZAB如何恢复故障，我希望你明确这样几个重点。</p><p>1.成员发现，是为了建立跟随者和领导者之间的领导者关系，并通过任期编号来确认这个领导者是否为最合适的领导者。</p><p>2.数据同步，是通过以领导者的数据为准的方式，来实现各节点数据副本的一致，需要你注意的是，基于“大多数”的提交原则和选举原则，能确保被复制到大多数节点并提交的提案，就不再改变。</p><p>在这里，我想特别强调一下，在ZooKeeper的代码实现中，处于提交（Committed）状态的提案是可能会改变的，为什么呢？</p><p>在ZooKeeper中，一个提案进入提交（Committed）状态，有两种方式：</p><ul><li><p>被复制到大多数节点上，被领导者提交或接收到来自领导者的提交消息（leader.COMMIT）而被提交。在这种状态下，提交的提案是不会改变的。</p></li><li><p>另外，在ZooKeeper的设计中，在节点退出跟随者状态时（在follower.shutdown()函数中），会将所有本地未提交的提案都提交。需要你注意的是，此时提交的提案，可能并未被复制到大多数节点上，而且这种设计，就会导致ZooKeeper中出现，处于“提交”状态的提案可能会被删除（也就是接收到领导者的TRUNC消息而删除的提案）。</p></li></ul><p>更准确的说，**在ZooKeeper中，被复制到大多数节点上的提案，最终会被提交，并不会再改变；而只在少数节点存在的提案，可能会被提交和不再改变，也可能会被删除。**为了帮助你理解，我来举个具体的例子。</p><ul><li><p>如果写请求对应的提案“SET X = 1”已经复制到大多数节点上，那么它是最终会被提交，之后也不会再改变。也就是说，在没有新的X赋值操作的前提下，不管节点怎么崩溃、领导者如何变更，你查询到的X的值都为1。</p></li><li><p>如果写请求对应的提案“SET X = 1”未被复制到大多数节点上，比如在领导者广播消息过程中，领导者崩溃了，那么，提案“SET X = 1”，可能被复制到大多数节点上，并提交和之后就不再改变，也可能会被删除。这个行为是未确定的，取决于新的领导者是否包含该提案。</p></li></ul><p>另外，我想补充下，在ZAB中，选举出了新的领导者后，该领导者不能立即处理写请求，还需要通过成员发现、数据同步2个阶段进行故障恢复。这是ZAB协议的设计决定的，不是所有的共识算法都必须这样，比如Raft选举出新的领导者后，领导者是可以立即处理写请求的。</p><p>最后，完成数据同步后，节点将进入广播状态，那ZAB是如何处理读写请求，又是如何广播消息的呢？下节课，我会重点带你了解这部分内容。</p><h2 id="课堂思考"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14#课堂思考"><span class="icon icon-link"></span></a>课堂思考</h2><p>我提到在ZAB中，提案提交的大多数原则和领导者选举的大多数原则，确保了被复制到大多数节点的提案就不再改变了。那么你不妨思考和推演一下，这是为什么呢？欢迎在留言区分享你的看法，与我一同讨论。</p><p>最后，感谢你的阅读，如果这节课让你有所收获，也欢迎你将它分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式协议与算法实战/03.协议和算法篇/14.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
