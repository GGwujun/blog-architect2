<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>加餐 | ZAB协议（三）：如何处理读写请求？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式协议与算法实战/03.协议和算法篇/15" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/01"><span>开篇词 | 想成为分布式高手？那就先把协议和算法烂熟于心吧</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02"><span>学习路径 | 分布式协议与算法你应该这么学</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇">02.理论篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/01"><span>01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/02"><span>加餐  | 拜占庭将军问题：如何基于签名消息实现作战计划的一致性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/03"><span>02 | CAP理论：分布式系统的PH试纸，用它来测酸碱度</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/04"><span>03 | ACID理论：CAP的酸，追求一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/05"><span>04 | BASE理论：CAP的碱，追求可用性</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇">03.协议和算法篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/01"><span>05 | Paxos算法（一）：如何在多个节点间确定某变量的值？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/02"><span>06 | Paxos算法（二）：Multi-Paxos不是一个算法，而是统称</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/03"><span>07 | Raft算法（一）：如何选举领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/04"><span>08 | Raft算法（二）：如何复制日志？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/05"><span>09 | Raft算法（三）：如何解决成员变更的问题？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/06"><span>10 | 一致哈希算法：如何分群，突破集群的“领导者”限制？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/07"><span>11 | Gossip协议：流言蜚语，原来也可以实现一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/08"><span>12 | Quorum NWR算法：想要灵活地自定义一致性，没问题！</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/09"><span>13 | PBFT算法：有人作恶，如何达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/10"><span>加餐 | PBFT算法：如何替换作恶的领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/11"><span>14 | PoW算法：有办法黑比特币吗？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/12"><span>15 | ZAB协议：如何实现操作的顺序性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/13"><span>加餐 | ZAB协议（一）：主节点崩溃了，怎么办？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14"><span>加餐 | ZAB协议（二）：如何从故障中恢复？</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15"><span>加餐 | ZAB协议（三）：如何处理读写请求？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/16"><span>加餐 | MySQL XA是如何实现分布式事务的？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/17"><span>加餐 | TCC如何实现指令执行的原子性？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/01"><span>16 | InfluxDB企业版一致性实现剖析：他山之石，可以攻玉</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02"><span>17  | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/03"><span>18 | Hashicorp Raft（二）：如何以“集群节点”为中心使用API？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/04"><span>19 | 基于Raft的分布式KV系统开发实战（一）：如何设计架构？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/05"><span>20 | 基于Raft的分布式KV系统开发实战（二）：如何实现代码？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语">05.结束语</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/01"><span>结束语 | 静下心来，享受技术的乐趣</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/02"><span>结课测试 | 这些分布式协议与算法的知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/summary">分布式协议与算法实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="ZooKeeper处理读写请求的原理" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#zookeeper处理读写请求的原理"><span>ZooKeeper处理读写请求的原理</span></a></li><li title="ZooKeeper代码是如何实现读写操作的呢？" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#zookeeper代码是如何实现读写操作的呢"><span>ZooKeeper代码是如何实现读写操作的呢？</span></a></li><li title="如何实现写操作？" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#如何实现写操作"><span>如何实现写操作？</span></a></li><li title="如何实现读操作？" data-depth="3"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#如何实现读操作"><span>如何实现读操作？</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#内容小结"><span>内容小结</span></a></li><li title="课堂思考" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#课堂思考"><span>课堂思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="加餐--zab协议三如何处理读写请求"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#加餐--zab协议三如何处理读写请求"><span class="icon icon-link"></span></a>加餐 | ZAB协议（三）：如何处理读写请求？</h1><p>你好，我是韩健！</p><p>你应该有这样的体会，如果你想了解一个网络服务，执行的第一个功能肯定是写操作，然后才执行读操作。比如，你要了解ZooKeeper，那么肯定会在zkCli.sh命令行中执行写操作（比如“create /geekbang 123”）写入数据，然后再是读操作（比如“get /geekbang”）查询数据。这样一来，你才会直观地理解ZooKeeper是如何使用的了。</p><p>在我看来，任何网络服务最重要的功能就是处理读写请求，因为我们访问网络服务本质上都是在执行读写操作，ZooKeeper也不例外。<strong>而且对ZooKeeper而言，这些功能更为重要，因为在ZooKeeper中，如何处理写请求，关乎着操作的顺序性，而操作的顺序性会影响节点的创建；如何处理读请求，关乎着一致性，它们又影响着客户端是否会读到旧数据。</strong></p><p>接下来，我会从ZooKeeper系统的角度，全面地分析整个读写请求的流程，帮助你更加全面、透彻地理解读写请求背后的原理。</p><p>你肯定知道，在ZooKeeper中，写请求是必须在领导者上处理，如果跟随者接收到了写请求，它需要将写请求转发给领导者，当写请求对应的提案被复制到大多数节点上时，领导者会提交提案，并通知跟随者提交提案。而读请求可以在任何节点上处理，也就是说，ZooKeeper实现的是最终一致性。</p><p>对你来说，理解了如何处理读写请求，不仅能理解读写这个最重要功能的核心原理，还能更好地理解ZooKeeper的性能和一致性。这样一来，当你在实际场景中安装部署ZooKeeper的时候，就能游刃有余地做资源规划了。比如，如果读请求比较多，你可以增加节点，配置5节点集群，而不是常见的3节点集群。</p><p>话不多说，我们进入今天的内容，一起探究ZooKeeper处理读写请求的背后原理和代码实现。</p><h2 id="zookeeper处理读写请求的原理"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#zookeeper处理读写请求的原理"><span class="icon icon-link"></span></a>ZooKeeper处理读写请求的原理</h2><p>其实，我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/229975">15讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>演示“如何实现操作顺序性”时，就已经介绍了ZooKeeper是如何处理读写请求的了。所以在这里我就不啰嗦了，只是在此基础上，再补充几点。</p><p>首先，在ZooKeeper中，与领导者“失联”的节点，是不能处理读写请求的。比如，如果一个跟随者与领导者的连接发生了读超时，设置了自己的状态为LOOKING，那么此时它既不能转发写请求给领导者处理，也不能处理读请求，只有当它“找到”领导者后，才能处理读写请求。</p><p>举个例子：当发生分区故障了，C与A（领导者）、B网络不通了，那么C将设置自己的状态为LOOKING，此时在C节点上既不能执行读操作，也不能执行写操作。<br/><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage22ad22dfaa624590885c4b8406deb445afad.9948b8bd.jpg" alt=""/></p><p>其次，当大多数节点进入到广播阶段的时候，领导者才能提交提案，因为提案提交，需要来自大多数节点的确认。</p><p>最后，写请求只能在领导者节点上处理，所以ZooKeeper集群写性能约等于单机。而读请求是可以在所有的节点上处理的，所以，读性能是能水平扩展的。也就是说，你可以通过分集群的方式来突破写性能的限制，并通过增加更多节点，来扩展集群的读性能。</p><p>熟悉了ZooKeeper处理读写请求的过程和原理后，相信你应该好奇这些功能在ZooKeeper代码中是如何实现的呢？</p><h2 id="zookeeper代码是如何实现读写操作的呢"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#zookeeper代码是如何实现读写操作的呢"><span class="icon icon-link"></span></a>ZooKeeper代码是如何实现读写操作的呢？</h2><h3 id="如何实现写操作"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#如何实现写操作"><span class="icon icon-link"></span></a>如何实现写操作？</h3><p>我先来说一说写操作，在ZooKeeper代码中，处理写请求的核心流程就像下图一样（为了帮你更好的理解这部分内容，我来演示一下复杂的情况，也就是跟随者接收到写请求的情况）。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagec78ac77c241713b154673e15083fd063428a.9eb2932d.jpg" alt=""/></p><p>接下来，咱们一起走一遍核心代码的流程，加深一下印象。</p><p>1.跟随者在FollowerRequestProcessor.processRequest()中接收到写请求。具体来说，写请求是系统在ZooKeeperServer.submitRequestNow()中发给跟随者的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">firstProcessor.processRequest(si);</span></div></pre></div><p>而firstProcessor，是在FollowerZooKeeperServer.setupRequestProcessors()中创建的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void setupRequestProcessors() {</span></div><div class="token-line"><span class="token plain">      // 创建finalProcessor，提交提案或响应查询     </span></div><div class="token-line"><span class="token plain">      RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span></div><div class="token-line"><span class="token plain">      // 创建commitProcessor，处理提案提交或读请求</span></div><div class="token-line"><span class="token plain">      commitProcessor = new CommitProcessor(finalProcessor,   Long.toString(getServerId()), true, getZooKeeperServerListener());</span></div><div class="token-line"><span class="token plain">      commitProcessor.start();</span></div><div class="token-line"><span class="token plain">      // 创建firstProcessor，接收发给跟随者的请求</span></div><div class="token-line"><span class="token plain">      firstProcessor = new FollowerRequestProcessor(this, commitProcessor);</span></div><div class="token-line"><span class="token plain">      ((FollowerRequestProcessor) firstProcessor).start();</span></div><div class="token-line"><span class="token plain">      // 创建syncProcessor，将提案持久化存储，并返回确认响应给领导者</span></div><div class="token-line"><span class="token plain">      syncProcessor = new SyncRequestProcessor(this, new SendAckRequestProcessor(getFollower()));</span></div><div class="token-line"><span class="token plain">      syncProcessor.start();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>需要你注意的是，跟随者节点和领导者节点的firstProcessor是不同的，这样当firstProcessor在ZooKeeperServer.submitRequestNow()中被调用时，就分别进入了跟随者和领导者的代码流程。另外，setupRequestProcessors()创建了2条处理链，就像下图的样子。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimaged5e7d5dfec8e64a2d3cb6f905421d5e918e7.17f281f8.jpg" alt=""/></p><p>其中，处理链1是核心处理链，最终实现了提案提交和读请求对应的数据响应。处理链2实现了提案持久化存储，并返回确认响应给领导者。</p><p>2.跟随者在FollowerRequestProcessor.run()中将写请求转发给领导者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 调用learner.request()将请求发送给领导者</span></div><div class="token-line"><span class="token plain">    zks.getFollower().request(request);</span></div></pre></div><p>3.领导者在LeaderRequestProcessor.processRequest()中接收写请求，并最终调用pRequest()创建事务（也就是提案），并持久化存储。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建事务</span></div><div class="token-line"><span class="token plain">    pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    // 分配事务标识符</span></div><div class="token-line"><span class="token plain">    request.zxid = zks.getZxid();</span></div><div class="token-line"><span class="token plain">    // 调用ProposalRequestProcessor.processRequest()处理写请求，并将事务持久化存储</span></div><div class="token-line"><span class="token plain">    nextProcessor.processRequest(request);</span></div></pre></div><p>在这里，需要你注意的是，写请求也是在ZooKeeperServer.submitRequestNow()中发给领导者的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">firstProcessor.processRequest(si);</span></div></pre></div><p>而firstProcessor，是在LeaderZooKeeperServer.setupRequestProcessors()中创建的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void setupRequestProcessors() {</span></div><div class="token-line"><span class="token plain">      // 创建finalProcessor，最终提交提案和响应查询</span></div><div class="token-line"><span class="token plain">      RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span></div><div class="token-line"><span class="token plain">      // 创建toBeAppliedProcessor，存储可提交的提案，并在提交提案后，从toBeApplied队列移除已提交的</span></div><div class="token-line"><span class="token plain">      RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());</span></div><div class="token-line"><span class="token plain">      // 创建commitProcessor，处理提案提交或读请求      </span></div><div class="token-line"><span class="token plain">      commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());</span></div><div class="token-line"><span class="token plain">      commitProcessor.start();</span></div><div class="token-line"><span class="token plain">      // 创建proposalProcessor，按照顺序广播提案给跟随者</span></div><div class="token-line"><span class="token plain">      ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor);</span></div><div class="token-line"><span class="token plain">            proposalProcessor.initialize();</span></div><div class="token-line"><span class="token plain">      // 创建prepRequestProcessor，根据请求创建提案      </span></div><div class="token-line"><span class="token plain">      prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);</span></div><div class="token-line"><span class="token plain">      prepRequestProcessor.start();</span></div><div class="token-line"><span class="token plain">      // 创建firstProcessor，接收发给领导者的请求</span></div><div class="token-line"><span class="token plain">      firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);</span></div><div class="token-line"><span class="token plain">      ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>需要你注意的是，与跟随者类似，setupRequestProcessors()给领导者也创建了2条处理链（其中处理链2是在创建proposalRequestProcessor时创建的）。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagef783f780e2d141a766579ba20c3b3d0a2283.f80c6ac5.jpg" alt=""/></p><p>其中，处理链1是核心处理链，最终实现了写请求处理（创建提案、广播提案、提交提案）和读请求对应的数据响应。处理链2实现了提案持久化存储，并返回确认响应给领导者自己。</p><p>4.领导者在ProposalRequestProcessor.processRequest()中，调用propose()将提案广播给集群所有节点。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">zks.getLeader().propose(request);</span></div></pre></div><p>5.跟随者在Follower.processPacket()中接收到提案，持久化存储，并返回确认响应给领导者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 接收、持久化、返回确认响应给领导者</span></div><div class="token-line"><span class="token plain">    fzk.logRequest(hdr, txn, digest);</span></div></pre></div><p>6.当领导者接收到大多数节点的确认响应（Leader.processAck()）后，最终在CommitProcessor.tryToCommit()提交提案，并广播COMMIT消息给跟随者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 通知跟随者提交</span></div><div class="token-line"><span class="token plain">    commit(zxid);</span></div><div class="token-line"><span class="token plain">    // 自己提交</span></div><div class="token-line"><span class="token plain">    zk.commitProcessor.commit(p.request);</span></div></pre></div><p>7.当跟随者接收到COMMIT消息后，在FollowerZooKeeperServer.commit()中提交提案，如果最初的写请求是自己接收到的，返回成功响应给客户端。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 必须顺序提交</span></div><div class="token-line"><span class="token plain">    long firstElementZxid = pendingTxns.element().zxid;</span></div><div class="token-line"><span class="token plain">    if (firstElementZxid != zxid) {</span></div><div class="token-line"><span class="token plain">      LOG.error(&quot;Committing zxid 0x&quot; + Long.toHexString(zxid)</span></div><div class="token-line"><span class="token plain">                + &quot; but next pending txn 0x&quot; + </span></div><div class="token-line"><span class="token plain">                Long.toHexString(firstElementZxid));</span></div><div class="token-line"><span class="token plain">      ServiceUtils.requestSystemExit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 将准备提交的提案从pendingTxns队列移除</span></div><div class="token-line"><span class="token plain">    Request request = pendingTxns.remove();</span></div><div class="token-line"><span class="token plain">    request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);</span></div><div class="token-line"><span class="token plain">    // 最终调用FinalRequestProcessor.processRequest()提交提案，并如果最初的写请求是自己接收到的，返回成功响应给客户端</span></div><div class="token-line"><span class="token plain">    commitProcessor.commit(request);</span></div></pre></div><p>这样，ZooKeeper就完成了写请求的处理。你要特别注意一下，在分布式系统中，消息或者核心信息的持久化存储很关键，也很重要，因为这是保证集群能稳定运行的关键。</p><p>当然了，写入数据，最终还是为了后续的数据读取，那么在ZooKeeper中，是如何实现读操作的呢？</p><h3 id="如何实现读操作"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#如何实现读操作"><span class="icon icon-link"></span></a>如何实现读操作？</h3><p>相比写操作，读操作的处理要简单很多，因为接收到读请求的节点，只需要查询本地数据，然后响应数据给客户端就可以了。读操作的核心代码流程，如图所示。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagef46df405d2a81f374e6e63b49c469506f26d.368e4c51.jpg" alt=""/></p><p>咱们一起走一遍核心代码的流程，加深一下印象。</p><p>1.跟随者在FollowerRequestProcessor.processRequest()中接收到读请求。</p><p>2.跟随者在FinalRequestProcessor.processRequest()中查询本地数据，也就是dataTree中的数据。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 处理读请求</span></div><div class="token-line"><span class="token plain">    case OpCode.getData: {</span></div><div class="token-line"><span class="token plain">      ......</span></div><div class="token-line"><span class="token plain">      // 查询本地dataTree中的数据</span></div><div class="token-line"><span class="token plain">      rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);</span></div><div class="token-line"><span class="token plain">      ......</span></div><div class="token-line"><span class="token plain">      break;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>3.然后跟随者响应查询到数据给客户端。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">case OpCode.getData : {</span></div><div class="token-line"><span class="token plain">      ......</span></div><div class="token-line"><span class="token plain">      // 响应查询到的数据给客户端</span></div><div class="token-line"><span class="token plain">      cnxn.sendResponse(hdr, rsp, &quot;response&quot;, path, stat, opCode);</span></div><div class="token-line"><span class="token plain">      break;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看，这样ZooKeeper就完成读操作的处理。在这里，我想补充一点，你可以dataTree理解为Raft的状态机，提交的数据，最终存放在dataTree中。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>本节课我主要带你了解了ZooKeeper处理读写请求的过程，以及ZooKeeper的代码实现和核心流程。我希望你明确这样几个重点。</p><p>1.与领导者“失联”的跟随者（比如发生分区故障时），是既不能处理写请求，也不能处理读请求的。</p><p>2.在ZooKeeper中，写请求只能在领导者节点上处理，读请求可以在所有节点上处理，实现的是最终一致性。</p><p>因为本讲是ZAB协议的最后一讲，为了帮你后续学习本课程没有提到的内容，我想补充几点。</p><p>首先，ZAB的术语众多，而且有些术语表达的是同一个含义，这些术语有些在文档中出现，有些在代码中出现。而你只有准确理解术语，才能更好地理解ZAB协议的原理，所以，我补充一些内容。</p><ul><li>提案（Proposal）：进行共识协商的基本单元，你可以理解为操作（Operation）或指令（Command），常出现在文档中。</li><li>事务（Transaction）：也是指提案，常出现在代码中。比如，pRequest2Txn()将接收到的请求转换为事务；再比如，未提交提案会持久化存储在事务日志中。在这里需要你注意的是，这个术语很容易引起误解，因为它不是指更广泛被接受的含义，具有ACID特性的操作序列。</li></ul><p>其次，在我看来，Raft算法和ZAB协议很类似，比如主备模式（也就是领导者、跟随者模型）、日志必须是连续的、以领导者的日志为准来实现日志一致等等。那为什么它们会比较类似呢？</p><p>**我的看法是，“英雄所见略同”。**比如ZAB协议要实现操作的顺序性，而Raft的设计目标，不仅仅是操作的顺序性，而是线性一致性，这两个目标，都决定了它们不能允许日志不连续，要按照顺序提交日志，那么，它们就要通过上面的方法实现日志的顺序性，并保证达成共识（也就是提交）后的日志不会再改变。</p><p>最后，我想就ZAB和Raft做个对比，来具体说说ZAB和Raft的异同。既然我们要做对比，那么首先要定义对比标准，我是这么考虑的：你应该有这样的体会，同一个功能，不同的同学实现的代码都会不一样（比如数据结构、代码逻辑），所以过于细节的比较，尤其是偏系统实现方面的，意义不大（比如跟随者是否转发写请求到领导者，不仅意义不大，而且这是ZAB和Raft都没有约定的，是集群系统需要考虑的），我们可以从核心原理上做对比。</p><ul><li><p>领导者选举：ZAB采用的“见贤思齐、相互推荐”的快速领导者选举（Fast Leader Election），Raft采用的是“一张选票、先到先得”的自定义算法。在我看来，Raft的领导者选举，需要通讯的消息数更少，选举也更快。</p></li><li><p>日志复制：Raft和ZAB相同，都是以领导者的日志为准来实现日志一致，而且日志必须是连续的，也必须按照顺序提交。</p></li><li><p>读操作和一致性：ZAB的设计目标是操作的顺序性，在ZooKeeper中默认实现的是最终一致性，读操作可以在任何节点上执行；而Raft的设计目标是强一致性（也就是线性一致性），所以Raft更灵活，Raft系统既可以提供强一致性，也可以提供最终一致性。</p></li><li><p>写操作：Raft和ZAB相同，写操作都必须在领导者节点上处理。</p></li><li><p>成员变更：Raft和ZAB都支持成员变更，其中ZAB以动态配置（dynamic configuration）的方式实现的。那么当你在节点变更时，不需要重启机器，集群是一直运行的，服务也不会中断。</p></li><li><p>其他：相比ZAB，Raft的设计更为简洁，比如Raft没有引入类似ZAB的成员发现和数据同步阶段，而是当节点发起选举时，递增任期编号，在选举结束后，广播心跳，直接建立领导者关系，然后向各节点同步日志，来实现数据副本的一致性。<strong>在我看来，ZAB的成员发现，可以和领导者选举合到一起，类似Raft，在领导者选举结束后，直接建立领导者关系，而不是再引入一个新的阶段；数据同步阶段，是一个冗余的设计，可以去除的，因为ZAB不是必须要先实现数据副本的一致性，才可以处理写请求，而且这个设计是没有额外的意义和价值的。</strong></p></li></ul><p>另外，ZAB和ZooKeeper强耦合，你无法在实际系统中独立使用；而Raft的实现（比如Hashicorp Raft）是可以独立使用的，编程友好。</p><h2 id="课堂思考"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15#课堂思考"><span class="icon icon-link"></span></a>课堂思考</h2><p>我提到ZooKeeper提供的是最终一致性，读操作可以在任何节点上执行。那么如果读操作访问的是备份节点，为什么无法保证每次都能读到最新的数据呢？欢迎在留言区分享你的看法，与我一同讨论。</p><p>最后，感谢你的阅读，如果这节课让你有所收获，也欢迎你将它分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式协议与算法实战/03.协议和算法篇/15.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
