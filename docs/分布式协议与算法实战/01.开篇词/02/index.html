<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>学习路径 | 分布式协议与算法你应该这么学 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式协议与算法实战/01.开篇词/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/01"><span>开篇词 | 想成为分布式高手？那就先把协议和算法烂熟于心吧</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02"><span>学习路径 | 分布式协议与算法你应该这么学</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇">02.理论篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/01"><span>01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/02"><span>加餐  | 拜占庭将军问题：如何基于签名消息实现作战计划的一致性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/03"><span>02 | CAP理论：分布式系统的PH试纸，用它来测酸碱度</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/04"><span>03 | ACID理论：CAP的酸，追求一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/02.理论篇/05"><span>04 | BASE理论：CAP的碱，追求可用性</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇">03.协议和算法篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/01"><span>05 | Paxos算法（一）：如何在多个节点间确定某变量的值？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/02"><span>06 | Paxos算法（二）：Multi-Paxos不是一个算法，而是统称</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/03"><span>07 | Raft算法（一）：如何选举领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/04"><span>08 | Raft算法（二）：如何复制日志？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/05"><span>09 | Raft算法（三）：如何解决成员变更的问题？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/06"><span>10 | 一致哈希算法：如何分群，突破集群的“领导者”限制？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/07"><span>11 | Gossip协议：流言蜚语，原来也可以实现一致性</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/08"><span>12 | Quorum NWR算法：想要灵活地自定义一致性，没问题！</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/09"><span>13 | PBFT算法：有人作恶，如何达成共识？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/10"><span>加餐 | PBFT算法：如何替换作恶的领导者？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/11"><span>14 | PoW算法：有办法黑比特币吗？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/12"><span>15 | ZAB协议：如何实现操作的顺序性？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/13"><span>加餐 | ZAB协议（一）：主节点崩溃了，怎么办？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/14"><span>加餐 | ZAB协议（二）：如何从故障中恢复？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/15"><span>加餐 | ZAB协议（三）：如何处理读写请求？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/16"><span>加餐 | MySQL XA是如何实现分布式事务的？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/03.协议和算法篇/17"><span>加餐 | TCC如何实现指令执行的原子性？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/01"><span>16 | InfluxDB企业版一致性实现剖析：他山之石，可以攻玉</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/02"><span>17  | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/03"><span>18 | Hashicorp Raft（二）：如何以“集群节点”为中心使用API？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/04"><span>19 | 基于Raft的分布式KV系统开发实战（一）：如何设计架构？</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/04.实战篇/05"><span>20 | 基于Raft的分布式KV系统开发实战（二）：如何实现代码？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语">05.结束语</a><ul><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/01"><span>结束语 | 静下心来，享受技术的乐趣</span></a></li><li><a href="/blog-architect2/分布式协议与算法实战/05.结束语/02"><span>结课测试 | 这些分布式协议与算法的知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式协议与算法实战/summary">分布式协议与算法实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="分布式算法的四度空间" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#分布式算法的四度空间"><span>分布式算法的四度空间</span></a></li><li title="拜占庭容错" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#拜占庭容错"><span>拜占庭容错</span></a></li><li title="一致性" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#一致性"><span>一致性</span></a></li><li title="可用性" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#可用性"><span>可用性</span></a></li><li title="性能" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#性能"><span>性能</span></a></li><li title="专栏内容该如何学？" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#专栏内容该如何学"><span>专栏内容该如何学？</span></a></li><li title="总结" data-depth="2"><a href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="学习路径--分布式协议与算法你应该这么学"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#学习路径--分布式协议与算法你应该这么学"><span class="icon icon-link"></span></a>学习路径 | 分布式协议与算法你应该这么学</h1><p>你好，我是韩健。</p><p>在正式开始学习这门课之前，我想先和你聊一聊怎么学，因为掌握了学习路径、建立了全局观之后，你才能达到事半功倍的效果。</p><p>我们都知道，分布式协议和算法（为了不啰嗦，咱们下文都简称分布式算法）很实用、也很火，很多后端工程师在面试的时候，都会被问及分布式、高可用、一致性这些专业名词背后的算法原理和实现方式。</p><p>但是分布式算法也是比较新的，快速发展的。比如，1989年莱斯利·兰伯特（Leslie Lamport）提出了Paxos，2006年，谷歌研发团队让Paxos在生产环境中落地，但是Paxos缺乏编程实现的必须细节，最终的算法实现仍是建立在一个未证明的算法之上。再后来，也就是到了2013，斯坦福大学的迭戈·安加罗（Diego Ongaro）和约翰·奥斯特霍德（John Ousterhout）提出了Raft，但是2016年，Raft仍在解决成员变更的Bug。</p><p>正因为技术比较新，所以尚未能沉淀为书，很多同学都找不到分布式算法方面的经典书籍，再加上互联网上中文资料错误多，他们在学习相关的分布式算法的时候，会觉得吃力和困惑。</p><p>那么，如何才能掌握一个相对新、而且又在蓬勃快速发展的技术知识呢？这就是我这节课想要跟你分享的内容：<strong>如何高效地学习和掌握分布式算法？</strong></p><p>在我看来，开发分布式系统最关键的就是根据场景特点，选择合适的算法，在一致性和可用性之间妥协折中，而妥协折中的关键就在于能否理解各算法的特点。</p><p>也就是说，我们先要弄清楚每个算法的特点是什么，适合怎样的场景，这样当你在开发分布式系统时，才能做到心中有数，游刃有余地选择适合的算法，来解决实际场景的问题。</p><p>那么问题来了：这些算法究竟有什么特点？适合怎样的场景呢？</p><h2 id="分布式算法的四度空间"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#分布式算法的四度空间"><span class="icon icon-link"></span></a>分布式算法的四度空间</h2><p>为了帮你更好地理解最常用的分布式算法的特点，我从拜占庭容错、一致性、性能和可用性四个纬度帮你整理了一张表，你可以对照着看一下：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage1c331cc7514e341fab7bd7044b37285f4433.37a94116.jpg" alt=""/></p><h2 id="拜占庭容错"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#拜占庭容错"><span class="icon icon-link"></span></a>拜占庭容错</h2><p>拜占庭错误是莱斯利·兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了一个完全不可信的场景，除了存在故障行为，还存在恶意行为。顾名思义，拜占庭容错（Byzantine Fault Tolerance，BFT），就是指能容忍拜占庭错误了。</p><p>而非拜占庭容错，又叫故障容错（Crash Fault Tolerance，CFT），解决的是分布式系统中存在故障，但不存在恶意节点的共识问题，比如进程奔溃，服务器硬件故障等等。</p><p>一般而言，在可信环境（比如企业内网）中，系统具有故障容错能力就可以了，常见的算法有二阶段提交协议（2PC）、TCC（Try-Confirm-Cancel）、Paxos算法、ZAB协议、Raft算法、Gossip协议、Quorum NWR算法。</p><p>而在不可信的环境（比如有人做恶）中，这时系统需要具备拜占庭容错能力，常见的拜占庭容错算法有POW算法、PBFT算法。</p><h2 id="一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#一致性"><span class="icon icon-link"></span></a>一致性</h2><p>一般来讲，我们将一致性分为三类。</p><ul><li>强一致性：保证写操作完成后，任何后续访问都能读到更新后的值。</li><li>弱一致性：写操作完成后，系统不能保证后续的访问都能读到更新后的值。</li><li>最终一致性：保证如果对某个对象没有新的写操作了，最终所有后续访问都能读到相同的最近更新的值。</li></ul><p>但是我要提醒你注意，强一致性是具有多种含义的。</p><p>首先，在埃里克·布鲁尔的猜想中，CAP中的强一致性（也就是C）是指ACID的C，系统状态的一致性，而这种一致性，可以通过二阶段提交协议来实现。</p><p>其次，在CAP定理中，CAP中的强一致性（也就是C）是指原子一致性（也就是线性一致性）。其中，Paxos、Raft能实现线性一致性，而ZooKeeper基于读性能的考虑，它通过ZAB协议提供的是最终一致性。</p><p>一般而言，在需要系统状态的一致性时，你可以考虑采用二阶段提交协议、TCC。在需要数据访问是的强一致性时，你可考虑Raft算法。在可用性优先的系统，你可以采用Gossip协议来实现最终一致性，并实现Quorum NWR来提供强一致性。</p><h2 id="可用性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#可用性"><span class="icon icon-link"></span></a>可用性</h2><p>可用性说的是任何来自客户端的请求，不管访问哪个非故障节点，都能得到响应数据，但不保证是同一份最新数据，可用性强调的是服务可用。</p><p>一般来讲，采用Gossip协议实现最终一致性系统，它的可用性是最高的，因为哪怕只有一个节点，集群还能在运行并提供服务。其次是Paxos算法、ZAB协议、Raft算法、Quorum NWR算法、PBFT算法、POW算法，它们能容忍一定数节点故障。</p><p>最后是二阶段提交协议、TCC，只有当所有节点都在运行时，才能工作，可用性最低。</p><h2 id="性能"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#性能"><span class="icon icon-link"></span></a>性能</h2><p>一般来讲，采用Gossip协议的AP型分布式系统，具备水平扩展能力，读写性能是最高的。其次是Paxos算法、ZAB协议、Raft算法，因为它们都是领导者模型，写性能受限于领导者，读性能取决于一致性实现。最后是二阶段提交协议和TCC，因为在实现事务时，需要预留和锁定资源，性能相对低。</p><p>以上就是这些算法的特点了，了解完这部分内容之后，我想你一定有这样的疑问：“老韩，这些算法看起来很深奥，我怎样才能搞懂它们呢？按部就班的学吗？”</p><p>根据我多年的经验，你之所以觉得这些算法和相关的分布式技术，学起来比较难，是因为它们比较新，缺乏体系化。如果这时有个全景图，帮你建立全局观，那么你就可以体系化的理解相关算法了，在提高学习效率同时，也能在实际场景中“按图索骥”的选用相关的算法，而这些就是我接下来想和你具体聊一聊的。</p><h2 id="专栏内容该如何学"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#专栏内容该如何学"><span class="icon icon-link"></span></a>专栏内容该如何学？</h2><p><strong>拜占庭将军问题：最复杂的分布式容错模型</strong><br/>**难度：**一颗星<br/><strong>学习材料：</strong> 01讲、加餐 | 拜占庭将军问题：如何基于签名消息实现作战计划的一致性？</p><p>拜占庭容错是分布式领域最复杂的容错模型，是你必须要了解的。另外，口信消息型拜占庭问题之解、签名消息型拜占庭问题之解，你可以通过预设不同的忠将数、叛将数，来推演下，在推演中学习和掌握。</p><p><strong>CAP理论：酸碱平衡之道</strong><br/><strong>难度：</strong> 二颗星<br/><strong>学习材料：</strong> 02讲、03讲、04讲</p><p>学习CAP理论的关键，不是仅仅知道CAP不可能三角，而是要能在C和A之间，根据实际场景特点，妥协权衡折中。这也是CAP猜想提出的初衷，希望业界能重视可用性，而不是只考虑ACID。</p><p><strong>分布式事务：进退与共</strong><br/><strong>难度：</strong> 二颗星<br/><strong>学习材料：</strong> 03讲，加餐 | MySQL XA是如何实现分布式事务的，加餐 | TCC如何实现指令的原子性</p><p>事务是指具有ACID特性的一组操作，要么全部执行，要么全部不执行，实现的是系统状态的一致性。一般在支付，或其他需要原子操作的场景下比较常用。</p><p>实现分布式事务，最常用的方法是二阶段提交协议和TCC，这两个算法的适用场景是不同的，二阶段提交协议实现的是数据层面的事务，比如XA规范采用的就是二阶段提交协议；TCC实现的是业务层面的事务，比如当操作不仅仅是数据库操作，还涉及其他业务系统的访问操作时，这时就应该考虑TCC了。</p><p><strong>分布式强一致性：你必须给我最新的数据</strong><br/><strong>难度：</strong> 五颗星<br/><strong>学习内容：</strong> 05讲、06讲、07讲、08讲、09讲、10讲。</p><p>很多同学经常误解的一个点，就是将Consensus（共识）当成了一致性，也就是称为Paxos、Raft为一致性算法，其实Paxos和Raft是共识算法。而之所以出现这个问题，是因为在很多中文文章中，将Consensus和Consistency都翻译成了一致性，其实这样是不合适的，因为共识（Consensus）和一致性（Consistency）是两个完全不同的概念。</p><ul><li>共识：各节点就指定值（Value）达成共识，而且达成共识后的值，就不再改变了。</li><li>一致性：是指写操作完成后，能否从各节点上读到最新写入的数据，如果立即能读到，就是强一致性，如果最终能读到，就是最终一致性。</li></ul><p>提到共识算法，Paxos是一个必须要提及的话题，而且ZAB协议、Raft算法都可以看作是Paxos变种，所以，你需要了解Paxos算法。</p><p>但因为Paxos算法的可理解性和可编程性痛点突出，所以在实际场景中，最常的共识算法是Raft，我们可以基于Raft实现强一致性系统，Raft是需要彻底掌握的，在学习时，你可以结合17讲、18讲、19讲、20讲来一起学习，从前传（Paxos）到理论，再到实战，彻底吃透和掌握。</p><p>而一致哈希是常用的寻址算法，能突破集群性能的领导者限制，也是需要我们掌握的。</p><p><strong>分布式最终一致性：数据旧点没关系</strong><br/>**难度：**三颗星<br/><strong>学习材料：</strong> 11讲、12讲。</p><p>无论实现分布式事务还是强一致性，性能和可用性都是挑战，在一些对性能或可用性要求比较高的场景，比如时序数据、统计数据、状态数据（QQ登录状态），最终一致性是首选，因为最终一致性系统不仅能提供出色的性能，还能实现水平扩展。而Gossip协议是实现最终一致性的常用方法。</p><p>如果实现了最终一致性，但有时可能需要临时提供强一致性能力，这个时候，你可以用Quorum NWR来实现。</p><p><strong>ZAB协议：ZooKeeper背后的一致性秘密</strong><br/><strong>难度：</strong> 二颗星<br/><strong>学习材料：</strong> 15讲，加餐 | ZAB协议（一）：主节点崩溃了，怎么办？加餐 | ZAB协议（二）：如何从故障中恢复？加餐 | ZAB协议（三）：如何处理读写请求？</p><p>ZooKeeper是一个常用的分布式协调服务，而且ZAB协议在共识算法的发展过程中起到了一个承前启后的作用，它受Paxos算法、原子广播协议的启发，又影响到后来的Raft算法。但从实战的角度，ZAB协议的实现，无法剥离ZooKeeper代码独立使用，<strong>所以这部分内容，我建议日常使用ZooKeeper的同学仔细学习一下，其他同学的话，可以选学。</strong></p><p><strong>拜占庭容错算法：有人作恶，如何达成共识</strong><br/><strong>难度：</strong> 二颗星<br/><strong>学习材料：</strong> 13讲、14讲，加餐 | PBFT算法：如何替换作恶的领导者？</p><p>在一个完全不可信的环境中（比如有人作恶），如果需要达成共识，那么我们就必须考虑拜占庭容错算法，常用的拜占庭容错算法有POW算法、PBFT算法，它们在区块链中应用广泛。</p><p><strong>实战：实践是最好的学习方式</strong><br/>**难度：**四颗星<br/><strong>学习材料：</strong> 16讲、17讲、18讲、19讲、20讲。</p><p>你可能有这样的体会，技术的学习往往是在模仿中开始的，在实战中顿悟升华。分布式算法的学习也不例外，技术是需要在实战中学习，也只有在实战中，你才能真正的理解技术。</p><p>他山之石，可以攻玉，为了帮助你更好地理解实际场景中一致性的实现，我会剖析InfluxDB企业版的一致性实现（强一致性和最终一致性两个方案）。也会分析一个流行的Raft实现（Hashicorp Raft），除了在代码中理解Raft算法，也会带你熟悉一下Hashicorp Raft的API接口，最终在19、20讲，带你使用API接口开发实现自己的分布式KV系统。</p><p>我啰嗦了那么多，其实就是为了让你更高效地掌握常用的分布式算法。另外，为了帮你更好的理解算法的特点和整体学习的思路，我做了个知识地图，方便你梳理整个知识体系。</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage1213122bdf34957c6277352ea51c43552213.f2fb0d79.png" alt=""/></p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式协议与算法实战/01.开篇词/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>生有涯知无涯，只有抓住技术本质，才能举一反三，以不变应万变。而本课程我带你了解的这些算法和理论，都是最经典和经得起时间检验的。</p><p>但学习的过程绝不会一帆风顺，如果你在学习过程中有困惑、茫然，甚至是沮丧，希望你能多留言，咱们聊一聊，一起想想办法，<strong>让我们把分布式算法学习这件意义非凡的事情坚持下去，一起攻克分布式系统设计的关键难题。</strong></p><p>现在，就让我们正式开始分布式算法之旅吧！一起享受技术的乐趣。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式协议与算法实战/01.开篇词/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
