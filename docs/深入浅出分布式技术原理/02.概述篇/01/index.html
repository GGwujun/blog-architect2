<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>01｜导读：以前因后果为脉络，串起网状知识体系 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入浅出分布式技术原理/02.概述篇/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/01.开篇词/01"><span>开篇词｜掌握好学习路径，分布式系统原来如此简单</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理/02.概述篇">02.概述篇</a><ul><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01"><span>01｜导读：以前因后果为脉络，串起网状知识体系</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/02"><span>02｜新的挑战：分布式系统是银弹吗？我看未必！</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/03"><span>03｜CAP 理论：分布式场景下我们真的只能三选二吗？</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐">03.春节加餐</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐/01"><span>春节加餐｜系统性思维，高效学习和工作的利器</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐/02"><span>春节加餐｜深入聊一聊计算机系统的时间</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐/03"><span>春节加餐｜技术债如房贷，是否借贷怎样取舍？</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇">04.分布式计算篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/01"><span>04｜注册发现： AP 系统和 CP 系统哪个更合适？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/02"><span>05｜负载均衡：从状态的角度重新思考负载均衡</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/03"><span>06｜配置中心：如何确保配置的强一致性呢？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/04"><span>07｜分布式锁：所有的分布式锁都是错误的？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/05"><span>08｜重试幂等：让程序 Exactly-once 很难吗？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/06"><span>09 | 雪崩（一）：熔断，让故障自适应地恢复</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/07"><span>10 | 雪崩（二）：限流，抛弃超过设计容量的请求</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/08"><span>11｜雪崩（三）：降级，无奈的丢车保帅之举</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/09"><span>12｜雪崩（四）：扩容，没有用钱解决不了的问题</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/10"><span>13｜可观测性（一）：如何监控一个复杂的分布式系统？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/11"><span>14｜可观测性（二）：如何设计一个高效的告警系统？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/12"><span>15｜故障（一）：预案管理竟然能让被动故障自动恢复？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/13"><span>16｜故障（二）：变更管理，解决主动故障的高效思维方式</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/14"><span>期中测试｜IM 系统设计实战</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/15"><span>期中测试答案｜这些问题你都答对了吗？</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇">05.分布式存储篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/01"><span>17｜分片（一）：如何选择最适合的水平分片方式？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/02"><span>18｜分片（二）：垂直分片和混合分片的 trade-off</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/03"><span>19｜复制（一）：主从复制从副本的数据可以读吗？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/04"><span>20｜复制（二）：多主复制的多主副本同时修改了怎么办？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/05"><span>21｜复制（三）：最早的数据复制方式竟然是无主复制？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/06"><span>22｜事务（一）：一致性，事务的集大成者</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/07"><span>23｜事务（二）：原子性，对应用层提供的完美抽象</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/08"><span>24｜事务（三）：隔离性，正确与性能之间权衡的艺术</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/09"><span>25｜事务（四）：持久性，吃一碗粉就付一碗粉的钱</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10"><span>26｜一致性与共识（一）：数据一致性都有哪些级别？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/11"><span>27｜一致性与共识（二）：它们是鸡生蛋还是蛋生鸡？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/12"><span>28｜一致性与共识（三）：共识与事务之间道不明的关系</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/06.总结篇">06.总结篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/06.总结篇/01"><span>29｜分布式计算技术的发展史：从单进程服务到 Service Mesh</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/06.总结篇/02"><span>30｜分布式存储技术的发展史：从 ACID 到 NewSQL</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/07.结束语">07.结束语</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/07.结束语/01"><span>结束语 ｜在分布式技术的大潮流中自由冲浪吧！</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/07.结束语/02"><span>期末测试｜来赴一场满分之约吧！</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/summary">深入浅出分布式技术原理</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="前因：分布式系统解决了什么问题" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#前因分布式系统解决了什么问题"><span>前因：分布式系统解决了什么问题</span></a></li><li title="后果：如何思考和处理分布式系统引入的新问题" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#后果如何思考和处理分布式系统引入的新问题"><span>后果：如何思考和处理分布式系统引入的新问题</span></a></li><li title="总结" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="01导读以前因后果为脉络串起网状知识体系"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#01导读以前因后果为脉络串起网状知识体系"><span class="icon icon-link"></span></a>01｜导读：以前因后果为脉络，串起网状知识体系</h1><p>你好，我是陈现麟。</p><p>在我们正式学习整个专栏之前，我特别设计了这个导读环节，让你在正式学习之前先拿到一份导航地图。</p><p>在开篇词里，我提到了我曾经参加过知乎圆桌会议，回答了“如何系统性地学习分布式系统”这个问题。在这节课的导读内容里，我会结合知乎中的回答，进一步提炼出分布式系统前因后果中的核心问题，帮你追本溯源，理清这个专栏的设计思路，总结深入学习的方法和路径。</p><p>学完这节课以后，你不仅能对课程思路心中有数，还能知道如何推导出一门技术的脉络，学会将零散的知识点连成网状的知识体系。</p><h2 id="前因分布式系统解决了什么问题"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#前因分布式系统解决了什么问题"><span class="icon icon-link"></span></a>前因：分布式系统解决了什么问题</h2><p>学习一个知识之前，我觉得比较好的方式是先理解它的前因后果：前因就是这个知识产生的过程中，它解决了什么问题，怎么样解决的。后果就是它的出现又带来了哪些新的问题，这样我们才能比较好地抓到它的脉络和关键点，不会一开始就迷失在细节中。</p><p>所以，学习分布式之前，<strong>我们要解决的第一个问题就是：分布式系统解决了什么问题，怎么样解决的</strong>？分布式系统的出现主要解决的是单体系统方面的不足，下面我们就具体来分析一下。</p><p>首先，分布式系统解决了单机性能瓶颈导致的成本问题。由于摩尔定律失效，廉价 PC 机的性能瓶颈无法继续突破，虽然小型机和大型机能实现更高的单机性能，但是成本太高，一般的公司很难承受。</p><p>比如 2008 年，阿里巴巴发起的“去 IOE ”运动（在 IT 建设过程中，去除 IBM 小型机、Oracle 数据库及 EMC 存储设备）的一个关键原因，就是这些商用小型机和存储设备的成本实在太高了。</p><p>然后，解决了用户量和数据量爆炸性地增大导致的成本问题。进入互联网时代，用户量爆炸性地增大，用户产生的数据量也随之增大。在 2015 年，全球数据总量达到 6 ZB（1 ZB 等于 1 万亿 GB），在 2020 年，全球数据总量已经达到了 44 ZB ，预计到 2030 年，全球数据总量将超过 2,500 ZB。</p><p>即使在这种情况下，单个用户或单条数据的价值，也是比软件时代（比如银行用户）的价值低很多的，所以人们必须寻找更经济的方案来处理和存储这些数据。并且，在用户量和数据量，大到一定程度之后，在单机系统的范围内，即使不计成本，可能也找不到好的解决方案。</p><p>接着，满足了业务高可用的要求。互联网产品基本都要求 7 * 24 小时提供服务，对于停止服务等故障是无法容忍的。如果想要提供高可用的服务，唯一的方式就是通过增加冗余来完成。那么就算是单机系统可以支撑的服务，因为要满足高可用的要求，也会变成一个分布式系统。</p><p>最后，分布式系统解决了大规模软件系统的迭代效率和成本的问题。如果一个大规模的软件系统是一个单体系统，那么大量的开发人员就只能将一个大规模软件，整体进行编译、测试和发布，这样一来开发语言和生态都比较单一，系统的迭代效率就会非常低。同时，对于系统的各个部分，我们也不能有针对性地进行成本优化，这会产生非常大的成本问题。</p><p>根据上面的四个原因，我们可以总结出<strong>在互联网时代，单机系统是无法解决成本、效率和高可用问题的</strong>，但是这三个问题，对所有的公司来说都是非常关键的问题，所以分布式系统就这样应运而生了，你也会发现，从单机系统到分布式系统的发展，是无法阻挡的技术大潮流。</p><p>那么，分布式系统又是怎么解决单机系统面临的成本、效率和高可用的问题呢？</p><p>其实很容易想到，就是将一些廉价的 PC 机，通过网络连接起来共同完成工作，并且在系统中提供冗余，来解决高可用的问题。其实我们从分布式系统的定义中，也能找到这个方法，分布式系统指的是由一组通过网络进行通信，为了完成共同的任务，而协调工作的计算机节点组成的系统。在这个定义中，可以看出分布式系统是通过多工作节点，来解决单机系统面临的成本、效率和高可用问题的。</p><p>刚才我们讨论了分布式系统解决了什么问题，怎么样解决的，由此得出，分布式系统的发展是无法阻挡的技术大潮流。下面我再进一步解释一下，如何理解分布式系统的出现，以及分布式系统在不同业务场景中的表现形式。</p><p>“旧时王谢堂前燕，飞入寻常百姓家”，用来形容 IT 技术最合适不过了。由于互联网的爆发性发展， IT 技术不再是实验室、科研机构和金融等相对前沿行业的专属技术，它快速地平民化了。如果一项技术能够平民化，那么一定是在成本、效率和稳定性方面都有非常突出的表现，也就是说必须物美价廉，<strong>所以我们可以把分布式系统看成是单体系统的平民化和物美价廉的版本</strong>。</p><p>目前分布式系统依然还在快速发展中，它不停地掀起一波又一波的浪潮，快速地席卷着 IT 技术的方方面面。我们可以看到它在不同的业务场景中有着不同的表现形式，比如流量路由策略加多副本部署（微服务是其中的一种架构形式）是无状态服务的分布式架构方案， Redis Cluster 和 Codis 等方案实现了缓存的分布式化，而 Kubernetes 则完成了操作系统的分布式进化。</p><p>NoSQL 掀起了数据库分布式化的第一波浪潮，而 NewSQL 则推动着支持 ACID 的关系数据库的分布式化，这是数据库分布式化的第二波浪潮，由此可见，分布式系统确实是无法避免的技术大潮流。</p><h2 id="后果如何思考和处理分布式系统引入的新问题"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#后果如何思考和处理分布式系统引入的新问题"><span class="icon icon-link"></span></a>后果：如何思考和处理分布式系统引入的新问题</h2><p>我们在上文中，分析了分布式系统的前因，知道了分布式系统是通过多工作节点，来解决单机系统面临的成本、效率和高可用问题的。但是有利就会有弊，它的出现也引入了分布式系统内部工作节点的协调问题，主要体现在分布式系统内部组件、实例之间，通过异步网络进行通信和协调的问题上。</p><p>所以在后果部分，<strong>我们主要来解决第二个问题：针对内部工作节点的协调问题，分布式系统是怎么做的</strong>？</p><p>我们先从简单的情况入手，对于**分布式计算（无状态）**的情况，系统内部的协调需要做哪些工作，我们围绕7个子问题进行思考。</p><p>其一，怎么找到服务？在分布式系统内部，会有不同的服务（角色），服务 A 怎么找到服务 B 是需要解决的问题。一般来说，服务注册与发现机制是常用的思路，所以，我们可以了解一下服务注册发现机制的实现原理，并且思考一下服务注册发现，是选择做成 AP 系统还是 CP 系统更合理。</p><p>其二，怎么找到实例？在找到服务之后，当前的请求应该发往服务的哪一个实例呢？一般来说，如果同一个服务的实例是完全对等的（无状态），那么按负载均衡的策略来处理就足够（轮询、权重、Hash、一致性Hash，FAIR 等各种策略的适用场景）。</p><p>如果同一个服务的实例不对等（有状态），那么就需要通过路由服务（元数据服务等）先确定，当前要访问的请求数据做到哪一个实例上，然后再进行访问。</p><p>其三，怎么管理配置？在分布式系统内部，会有不同的服务（角色），每一个服务都有多个实例，并且还可能自动扩容和缩容。在这样的情况下，通过配置文件的方式，来管理配置是低效、易出错的，对于这个问题，一般的思路是通过一个中心化的存储来统一管理系统的配置，即配置中心。</p><p>其四，怎么进行协同？在单体系统中，所有的功能模块都在一个进程中，系统内部进行协同非常简单， 直接调用系统的API 加锁就可以了。但是在分布式系统中，由于不同的功能模块已经拆分为不同的服务，并且一般都运行在不同的机器上，这个时候系统中加锁相关 API 就不能使用了。对于这个问题，我们可以通过一个跨进程与机器的分布式锁来解决。</p><p>其五，怎么确保请求只执行一次？在分布式系统中，各个模块之间通过网络进行连接。如果出现了网络抖动等情况，会导致模块之间的调用失败，而调用失败就有可能触发重试策略，使得程序可能出现没有执行或者多次执行的情况。一般来说，重试加上幂等是分布式系统中，确保请求只执行一次的方法。</p><p>其六，怎么避免雪崩？系统雪崩是指由于正反馈循序导致不断扩大规则的故障。一次雪崩通常是由于整个系统中，一个很小的部分出现故障而引发，进而导致系统的其他部分也出现故障。比如，系统中某一个服务的一个实例出现故障，导致负载均衡将该实例摘除，从而引起其他实例负载升高，最终导致该服务的所有实例像多米诺骨牌一样，一个一个全部出现故障。</p><p>避免雪崩的策略比较简单，主要是两个思路，一个是<strong>快速失败和降级机制</strong>（熔断、降级、限流等），通过快速减少系统负载来避免雪崩的发生；另一个是<strong>弹性扩容机制</strong>，通过快速增加系统的服务能力来避免雪崩的发生。我们可以根据不同的场景做出不同的选择，或者两个策略都使用。</p><p>一般来说，快速失败会导致部分的请求失败，如果分布式系统内部，对一致性要求很高的话，快速失败会带来系统数据不一致的问题。这种情况下，弹性扩容会是一个比较好的选择，但是弹性扩容的实现成本比快速失败要大，响应时间也更长。</p><p>其七，怎么监控告警和故障恢复？对于一个分布式系统来说，如果我们不能清楚地了解内部的状态，那么系统的稳定性是没有办法完全保障的。所以我们一定要完善分布式系统的监控（比如接口的时延和可用性等信息），分布式追踪 Trace ，模拟故障的混沌工程以及相关的告警等机制。同时做好故障恢复预案，确保在故障发生的时候，能够快速恢复故障。</p><p>接下来，我们再来围绕4个子问题思考一下，**分布式存储（有状态）**的内部协调是怎么做的，因为，前面介绍的分布式计算的协调方式在分布式存储中同样适用，就不再重复了。</p><p>首先，在 CAP 及其相关理论与权衡方面，需要了解 ACID 、 BASE 和 CAP 理论这三个主题。我推荐你阅读一篇文章以及文章后面相关的参考文献，读完后你就能很好地理解 CAP 理论中的取舍了，这是英文版本：<a target="_blank" rel="noopener noreferrer" href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/">https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，这是中文版本：<a target="_blank" rel="noopener noreferrer" href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p><p>然后，我们来思考怎么做数据分片。单机系统是不可能存储所有数据的，所以需要解决怎么将数据按一定的规则，分别存储到不同的机器上这个问题，目前使用较多的方案是：Hash 和 Region 分片的策略，但是要注意了解一下它们的优缺点和各自的应用场景。</p><p>接着，我们讨论一下怎么做数据复制这方面。为了满足系统的高可用要求，需要对数据做冗余处理，目前的方案主要为：中心化方案（主从复制、一致性协议，比如 Raft 和 Paxos 等）和去中心化的方案（ Quorum 和 Vector Clock），我们需要了解它们的优缺点，各自的应用场景，以及对系统外部表现出来的数据一致性级别（线性一致性、顺序一致性、最终一致性等）。</p><p>最后，我们来看看怎么做分布式事务。对于分布式系统来说，要实现事务，首先需要对并发事务进行排序的能力，这样在事务冲突的时候，就可以确认哪个事务提交成功，哪个事务提交失败。</p><p>在单机系统中，这完全不是问题，简单地通过时间戳加序号的方式就可以实现了。但是对于分布式系统来说，系统中机器的时间不能完全同步，并且单台机器的序号也没有全局意义，所以，按时间戳加序号的方式是不行的。</p><p>如果整个系统选一台机器，按照单机的模式生产事务 ID 是可以的，同城多中心和短距离的异地多中心也都没有问题。但是想做成全球分布式系统的话，每一次事务都要去一个节点获取事务ID的成本太高（比如中国杭州到美国东部的 RTT 为 200+ ms），我们可以<strong>参考 Google 的 Spanner ，它是通过 GPS 和原子钟，实现 TrueTime API 来解决这个问题，从而实现全球分布式数据库的</strong>。</p><p>有了事务 ID 后，通过 2PC 或者 3PC 协议来实现分布式事务的原子性，其他部分和单机事务差别不大，就不再细说了。</p><p>到这里，我们已经对分布式系统的脉络有了基本的概念，接下来就可以进入<strong>细节学习</strong>的阶段了，对分布式系统的理解深入与否，细节的深入度是很重要的评价指标，毕竟“魔鬼在细节”，所以这也是非常辛苦的阶段。这里我们可以从两个方面进行系统地学习：</p><p>首先<strong>从实践出发</strong>，研究目前比较常用的分布式系统的设计，HDFS 或者 GFS（分布式文件系统）、Kafka 和 Pulsar（分布式消息队列），Redis Cluster 和 Codis（分布式缓存），MySQL 的分库分表（传统关系型数据库的分布式方案），MongoDB 的 Replica Set 和 Sharing 机制集（NoSQL 数据库），TiDB（NewSQL）以及一些微服务框架等。</p><p>然后<strong>从理论出发</strong>，研究分布式相关的论文，这里推荐一本书“ Designing Data-Intensive Applications ”（中文版本：数据密集型应用系统设计），推荐你先把书整体看一遍，然后找到比较感兴趣的章节，再仔细读一读该章节中涉及的相关参考文献。</p><p>最后，为了让你更好地理解，如何处理分布式系统引入的，内部工作节点的协调问题，我把它们总结为下面三类问题。</p><p>首先是<strong>路由问题</strong>，分布式系统由单体系统拆分而来，必然会导致分布式系统内部，出现复杂的路由问题。路由问题主要是解决分布式系统内部各服务和实例之间的通信，我们可以将“怎么找到服务”和“怎么找到实例”等服务注册发现和负载均衡的问题，理解为正常情况下的路由问题，将“怎么做数据分片”的问题，理解为带状态的路由问题，将“怎么避免雪崩”涉及的熔断、降级等快速失败和降级机制，理解为异常情况下的路由问题。</p><p>接下来是<strong>共识问题</strong>，分布式系统的各个组件是运行在不同机器上的不同进程，因为程序总是需要按一定的逻辑有序地执行，所以需要一个办法，来协调分布式系统内部，已经各自为政的服务和实例，而共识就是讨论并解决这一类问题的，例如“怎么做数据复制”、“怎么做分布式事务”和“怎么做分布式锁”里，都会涉及共识问题。</p><p>最后是<strong>运维问题</strong>，分布式系统相对于单体系统是非常碎片化的，如果还依靠人肉运维，在效率上是完全行不通的，所以催生了一系列自动化运维的工具和平台来解决这一类问题，例如“怎么管理配置”和“怎么监控告警和故障恢复”都涉及运维的问题。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01#总结"><span class="icon icon-link"></span></a>总结</h2><p>通过这样一篇导读，我想告诉你，在学习新知识的时候，只学点状的知识是非常容易忘记的，而只学线状的知识又很难触类旁通，只有点、线结合，形成网状的知识体系，如下图这样，才能举一反三、融会贯通。<br/><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimage0a0c0a72636df95c698ea571d4146032820c.f490a56b.jpg" alt=""/><br/>所以，在这个专栏中，我会<strong>以分布式系统的前因后果为脉络，打造一条由浅入深、从简单到复杂的学习路径</strong>，并且会从路由问题、共识问题和运维问题这三大角度，对分布式系统的知识点进行交叉串讲。当你按照这条线性的路径完成学习后，将会得到一个网状的知识体系。</p><p>在课程导读中，我分享了如何学习、思考分布式技术原理的方法和路径，最后我想特别邀请你也来分享一下自己学习分布式系统的好方法，或者你也可以说说你在学习、工作中遇到的具体问题和困惑，非常期待你的留言。如果这节课对你有帮助，也推荐你分享给更多的同事、朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入浅出分布式技术原理/02.概述篇/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
