<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>26｜一致性与共识（一）：数据一致性都有哪些级别？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入浅出分布式技术原理/05.分布式存储篇/10" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/01.开篇词/01"><span>开篇词｜掌握好学习路径，分布式系统原来如此简单</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇">02.概述篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/01"><span>01｜导读：以前因后果为脉络，串起网状知识体系</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/02"><span>02｜新的挑战：分布式系统是银弹吗？我看未必！</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/02.概述篇/03"><span>03｜CAP 理论：分布式场景下我们真的只能三选二吗？</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐">03.春节加餐</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐/01"><span>春节加餐｜系统性思维，高效学习和工作的利器</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐/02"><span>春节加餐｜深入聊一聊计算机系统的时间</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/03.春节加餐/03"><span>春节加餐｜技术债如房贷，是否借贷怎样取舍？</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇">04.分布式计算篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/01"><span>04｜注册发现： AP 系统和 CP 系统哪个更合适？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/02"><span>05｜负载均衡：从状态的角度重新思考负载均衡</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/03"><span>06｜配置中心：如何确保配置的强一致性呢？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/04"><span>07｜分布式锁：所有的分布式锁都是错误的？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/05"><span>08｜重试幂等：让程序 Exactly-once 很难吗？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/06"><span>09 | 雪崩（一）：熔断，让故障自适应地恢复</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/07"><span>10 | 雪崩（二）：限流，抛弃超过设计容量的请求</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/08"><span>11｜雪崩（三）：降级，无奈的丢车保帅之举</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/09"><span>12｜雪崩（四）：扩容，没有用钱解决不了的问题</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/10"><span>13｜可观测性（一）：如何监控一个复杂的分布式系统？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/11"><span>14｜可观测性（二）：如何设计一个高效的告警系统？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/12"><span>15｜故障（一）：预案管理竟然能让被动故障自动恢复？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/13"><span>16｜故障（二）：变更管理，解决主动故障的高效思维方式</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/14"><span>期中测试｜IM 系统设计实战</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/04.分布式计算篇/15"><span>期中测试答案｜这些问题你都答对了吗？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇">05.分布式存储篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/01"><span>17｜分片（一）：如何选择最适合的水平分片方式？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/02"><span>18｜分片（二）：垂直分片和混合分片的 trade-off</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/03"><span>19｜复制（一）：主从复制从副本的数据可以读吗？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/04"><span>20｜复制（二）：多主复制的多主副本同时修改了怎么办？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/05"><span>21｜复制（三）：最早的数据复制方式竟然是无主复制？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/06"><span>22｜事务（一）：一致性，事务的集大成者</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/07"><span>23｜事务（二）：原子性，对应用层提供的完美抽象</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/08"><span>24｜事务（三）：隔离性，正确与性能之间权衡的艺术</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/09"><span>25｜事务（四）：持久性，吃一碗粉就付一碗粉的钱</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10"><span>26｜一致性与共识（一）：数据一致性都有哪些级别？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/11"><span>27｜一致性与共识（二）：它们是鸡生蛋还是蛋生鸡？</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/12"><span>28｜一致性与共识（三）：共识与事务之间道不明的关系</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/06.总结篇">06.总结篇</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/06.总结篇/01"><span>29｜分布式计算技术的发展史：从单进程服务到 Service Mesh</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/06.总结篇/02"><span>30｜分布式存储技术的发展史：从 ACID 到 NewSQL</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/07.结束语">07.结束语</a><ul><li><a href="/blog-architect2/深入浅出分布式技术原理/07.结束语/01"><span>结束语 ｜在分布式技术的大潮流中自由冲浪吧！</span></a></li><li><a href="/blog-architect2/深入浅出分布式技术原理/07.结束语/02"><span>期末测试｜来赴一场满分之约吧！</span></a></li></ul></li><li><a href="/blog-architect2/深入浅出分布式技术原理/summary">深入浅出分布式技术原理</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="一致性问题的来源" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#一致性问题的来源"><span>一致性问题的来源</span></a></li><li title="线性一致性" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#线性一致性"><span>线性一致性</span></a></li><li title="顺序一致性" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#顺序一致性"><span>顺序一致性</span></a></li><li title="因果一致性" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#因果一致性"><span>因果一致性</span></a></li><li title="最终一致性" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#最终一致性"><span>最终一致性</span></a></li><li title="总结" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="26一致性与共识一数据一致性都有哪些级别"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#26一致性与共识一数据一致性都有哪些级别"><span class="icon icon-link"></span></a>26｜一致性与共识（一）：数据一致性都有哪些级别？</h1><p>你好，我是陈现麟。</p><p>通过学习“事务”序列的内容，我们从事务的四个特性 ACID 的角度讨论了相关的知识与技术原理，这样在以后的工作中，事务对我们来说就不再是一个陌生和难懂的概念，而是越发清晰了。我们能清楚地知道事务能提供哪些保障，我们的代码逻辑可能会出现什么样的异常情况，以及怎么避免这些异常情况的出现。恭喜你在学习分布式的道路上又前进了一大步！</p><p>不过，在前面课程的学习中，我们经常会碰到两个概念：多副本数据的一致性和多节点的共识，比如在分布式锁、事务的原子性等场景中。其实在分布式系统中，一致性和共识是两个绕不过的话题，现在各种各样的分布式系统都是建立在一致性和共识之上的，可以说<strong>没有一致性和共识，就没有可用的分布式系统。</strong></p><p>既然一致性和共识对于分布式系统来说这么关键，那么我们一定要好好掌握。可是，通过前面课程中对一致性和共识场景的讨论，你现在虽然对二者有了很多的感性认识，知道在什么场景下会遇到一致性和共识方面的问题，也知道一些具体的解决方案，但是如果要你具体介绍一致性和共识的话，心里是不是不太有底呢？</p><p>所以，从这节课开始，我们将一起花三节课的时间来解决这个问题。这一节课，我们先介绍一致性问题的来源，然后我们从一致性模型从强到弱的角度，来介绍几种经典的一致性的模型，并且一起讨论和对比各个一致性模型之间的差异。</p><h2 id="一致性问题的来源"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#一致性问题的来源"><span class="icon icon-link"></span></a>一致性问题的来源</h2><p>虽然数据一致性是分布式系统的基石，但是其实最早研究一致性的场景并不是分布式系统，而是多路处理器。不过我们可以将多路处理器理解为单机计算机系统内部的分布式场景，它有多个执行单元，每一个执行单元都有自己的存储（缓存），一个执行单元修改了自己存储中的一个数据后，这个数据在其他执行单元里面的副本就面临数据一致的问题。</p><p>当时间走到 1990 年代时，由于互联网公司的快速发展，单机系统在计算和存储方面都面临瓶颈，分布式是一个必然的选择，但是这也进一步放大了数据一致性面临的问题。对于数据的一致性，最理想的模型当然是表现得和一份数据完全一样，修改没有延迟，即所有的数据修改后立即被同步，但是这在现实世界中，数据的传播是需要时间的，所以<strong>理想的一致性模型是不存在的</strong>。</p><p>不过从应用层的角度来看，我们并不需要理想的一致性模型，只需要一致性模型能满足业务场景的需求就足够了，比如在一些统计点赞数的场景中，是能容忍一定的误差的，而评论之类的场景中，可能只要有因果关系的操作顺序一致就可以了。</p><p>同时由于一致性要求越高，实现的难度和性能消耗就越大，所以我们<strong>可以通过评估业务场景来降低数据一致性的要求</strong>，这样人们就定义了不同的一致性模型来满足不同的需求。是不是发现了这里的思考逻辑和事务的隔离级别一样了？都是正确性和性能之前的衡权。</p><p>讨论完了一致性问题的来源后，接下来我们从客户端读写操作的维度来讨论一致性模型。由于一致性模型的定义大多是基于数学语言来定义的，理解起来有一定的难度，所以在课程中，我们尽量用简单的语言来讨论。</p><p>接下来，我们将讨论四个经典且常见的一致性模型：线性一致性、顺序一致性、因果一致性和最终一致性。</p><h2 id="线性一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#线性一致性"><span class="icon icon-link"></span></a>线性一致性</h2><p>线性一致性模型（Linearizability）是 Herlihy 和 Wing 等于 1987 年在论文 “Axioms for Concurrent Objects” 中提出的，线性一致性也被称为原子一致性（Atomic Consistency）、强一致性（Strong Consistency）、立即一致性（Immediate Consistency）和外部一致性（External Consistency）。</p><p>线性一致性是非常重要的一个一致性模型，在分布性锁、Leader 选举、唯一性约束等很多场景都可以看到它的身影。对于线性一致性的描述，我们可以从读写操作的维度来描述。</p><p>对于写操作来说，任意两个写操作 x1 和 x2：</p><ul><li>如果写 x1 操作和写 x2 操作有重叠，那么可能 x1 覆盖 x2，也可能 x2 覆盖 x1；</li><li>如果写 x1 操作在写 x2 开始前完成，那么 x2 一定覆盖 x1。</li></ul><p>对于读操作来说：</p><ul><li>写操作完成后，所有的客户端都能立即观察到；</li><li>对于多个客户端来说，必须读取到一样的顺序。</li></ul><p>我们可以看到，线性一致性保证了所有的读取都可以读到最新写入的值，即一旦新的值被写入或读取，所有后续的读都会看到写入的值，直到它被再次覆盖。<strong>在线性一致性模型中不论是数据的覆盖顺序还是读取顺序，都是按时间线从旧值向新值移动，而不会出现旧值反转的情况。</strong></p><h2 id="顺序一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#顺序一致性"><span class="icon icon-link"></span></a>顺序一致性</h2><p>顺序一致性模型（Sequential Consistency）是 Leslie Lamport 在 1979 年发表的论文 “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Program” 中提出的，在论文中具体的定义如下：</p><blockquote><p>A multiprocessor is said to be sequentially consistent if the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.<br/><br/>如果任何执行的结果与所有处理器的操作都以某种顺序执行的结果相同，并且每个单独的处理器的操作按照其程序顺序出现在该序列中，则称多处理器是顺序一致的。</p></blockquote><p>对于顺序一致性，论文中的定义虽然严谨，但是理解起来也是有难度的，它需要掌握一些前置的定义，比如 “program order”。不过在这里，我们依然可以用简单的语言来描述。</p><p>对于写操作来说，任意两个写操作 x1 和 x2：</p><ul><li>如果写 x1 操作和写 x2 操作有重叠，那么可能 x1 覆盖 x2，也可能 x2 覆盖 x1；</li><li>当写 x1 操作在写 x2 开始前完成，如果两个写操作没有因果关系，当写 x1 操作在写 x2 开始前完成，那么有可能 x1 覆盖 x2，也有可能 x2 覆盖 x1；如果两个写操作有因果关系，即同一台机器节点先写 x1，或者先看到 x1 然后再写 x2，则所有节点必须用 x2 覆盖 x1。</li></ul><p>对于读操作来说：</p><ul><li>如果写操作 x2 覆盖 x1 完成，那么如果一个客户端到 x2 后，它就无法读取到 x1 了，但是这个时候，其他的客户端还可以观察到 x1；</li><li>对于多个客户端来说，必须观察到一样的顺序。</li></ul><p>相对于线性一致性来说，<strong>顺序一致性在一致性方面有两点放松</strong>：</p><ul><li>对于写操作，对没有因果关系的非并发写入操作，不要求严格按时间排序；</li><li>对于读操作，只要求所有的客户端观察到的顺序一致性，不要求写入后，所有的客户端都必须读取新值。</li></ul><h2 id="因果一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#因果一致性"><span class="icon icon-link"></span></a>因果一致性</h2><p>因果一致性模型（Causal Consistency）是 Mustaque Ahamad, Gil Neiger, James E. Burns, Prince Kohli, Phillip W. Hutto 在 1991 年发表的论文 “Causal memory: definitions, implementation, and programming” 中提出的<strong>一种一致性强度低于顺序一致性的模型</strong>。在这里，我们依然从读写操作的维度来进行描述。</p><p>对于写操作来说，任意两个写操作 x1 和 x2：</p><ul><li>如果两个写操作没有因果关系，那么写 x1 操作在写 x2 开始前完成，有的节点是 x1 覆盖 x2，有的节点则 x2 可能覆盖 x1；</li><li>如果两个写操作有因果关系，即同一台机器节点先写 x1，或者先看到 x1 然后再写 x2，则所有节点必须用 x2 覆盖 x1。</li></ul><p>对于读操作来说：</p><ul><li>如果写操作 x2 覆盖 x1 完成，那么如果一个客户端到 x2 后，它就无法读取到 x1 了，但是这个时候，其他的客户端还可以观察到 x1。</li></ul><p>相对于顺序一致性来说，<strong>因果一致性在一致性方面有两点放松</strong>：</p><ul><li>对于写操作，对没有因果关系的非并发写入操作，不仅不要求按时间排序，还不再要求节点之间的写入顺序一致了；</li><li>对于读操作，由于对非并发写入顺序不再要求一致性，所以自然也无法要求多个客户端必须观察到一样的顺序。</li></ul><h2 id="最终一致性"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#最终一致性"><span class="icon icon-link"></span></a>最终一致性</h2><p>最终一致性模型（Eventual Consistency）是 Amazon 的 CTO Werner Vogels 在 2009 年发表的一篇论文 “Eventual Consistency” 里提出的，<strong>它是 Amazon 基于 Dynamo 等系统的实战经验所总结的一种很务实的实现</strong>，它不同于前面几种由大学计算机科学的教授提出的一致性模型，所以也没有非常学院派清晰的定义，但是我们依然可以从读写操作的维度来描述它。</p><p>对于同一台机器的两个写操作 x1 和 x2 来说：</p><ul><li>如果写 x1 操作在写 x2 开始前完成，那么所有节点在最终某时间点后，都会用 x2 覆盖 x1。</li></ul><p>对于读操作来说：</p><ul><li>在数据达到最终一致性的过程中，客户端的多次观察可以看到的结果是 x1 和 x2 中的任意值；</li><li>在数据达到最终一致性的过程后，所有客户端都将只能观察到 x2。</li></ul><p>我们可以看出来，“最终”是一个模糊的、不确定的概念，它是没有明确上限的，Vogels 提出这个不一致的时间窗口可能是由通信延迟、负载和复制次数造成的，但是最终所有进程的观点都一致，这个不一致的时间窗口可能是几秒也可能是几天。</p><p>所以，<strong>最终一致性是一个一致性非常低的模型</strong>，但是它能非常高性能地实现，在一些业务量非常大，但是对一致性要求不高的场景，是非常推荐使用的。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#总结"><span class="icon icon-link"></span></a>总结</h2><p>到这里，我们已经讨论完了几种最经典也最常见的一致性模型，现在我们来对这节课的内容做一个总结。</p><p>首先，我们讨论了一致性问题最早出现在多路处理器的场景，现在在分布式系统中广泛出现。同时，我们还得出了一个结论：对一致性模型进行分级是正确性和性能之间的一个权衡。</p><p>接着，我们从一致性模型强弱的维度，讨论了四个经典一致性模型的定义与差异，这里我们再从其他的维度描述一下，让你对一致性模型有一个更立体的理解。</p><p>第一，现在可以实现的一致性级别最强的是线性一致性，它是指所有进程看到的事件历史一致有序，并符合时间先后顺序, 单个进程遵守 program order，并且有 total order。</p><p>第二，是顺序一致性，它是指所有进程看到的事件历史一致有序，但不需要符合时间先后顺序, 单个进程遵守 program order，也有 total order。</p><p>第三，是因果一致性，它是指所有进程看到的因果事件历史一致有序，单个进程遵守 program order，不对没有因果关系的并发排序。</p><p>第四，是最终一致性，它是指所有进程互相看到的写无序，但最终一致。不对跨进程的消息排序。在课程“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/496934">复制（三）：最早的数据复制方式竟然是无主复制？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中讨论的 Quorum 机制就是最终一致性。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/深入浅出分布式技术原理/05.分布式存储篇/10#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>通过对一致性模型的学习，你可以通过读写操作序列，分别举出线性一致性、顺序一致性、因果一致性和最终一致性的例子吗？</p><p>欢迎你在留言区发表你的看法。如果这节课对你有帮助，也推荐你分享给更多的同事、朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入浅出分布式技术原理/05.分布式存储篇/10.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
