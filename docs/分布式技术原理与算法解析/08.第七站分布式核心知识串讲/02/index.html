<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      34 | 搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行 - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect2/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect2/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-architect2/分布式协议与算法实战">分布式协议与算法实战</a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式数据库30讲">分布式数据库30讲</a></li><li><a href="/blog-architect2/分布式金融架构课">分布式金融架构课</a></li><li><a href="/blog-architect2/李智慧高并发架构实战课">李智慧高并发架构实战课</a></li><li><a href="/blog-architect2/深入浅出分布式技术原理">深入浅出分布式技术原理</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect2/分布式技术原理与算法解析">分布式技术原理与算法解析</a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/01.课前必读">01.课前必读</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/01.课前必读/01"><span>开篇词 | 四纵四横，带你透彻理解分布式技术</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/01.课前必读/02"><span>01 | 分布式缘何而起：从单兵，到游击队，到集团军</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/01.课前必读/03"><span>02 | 分布式系统的指标：啥是分布式的三围</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步">02.第一站分布式协调与同步</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步/01"><span>03 | 分布式互斥：有你没我，有我没你</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步/02"><span>04 | 分布式选举：国不可一日无君</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步/03"><span>05 | 分布式共识：存异求同</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步/04"><span>06 | 分布式事务：All or nothing</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步/05"><span>07 | 分布式锁：关键重地，非请勿入</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/02.第一站分布式协调与同步/06"><span>08 | 分布式技术是如何引爆人工智能的？</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度">03.第二站分布式资源管理与负载调度</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度/01"><span>09 | 分布式体系结构之集中式结构：一人在上，万人在下</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度/02"><span>10 | 分布式体系结构之非集中式结构：众生平等</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度/03"><span>11 | 分布式调度架构之单体调度：物质文明、精神文明一手抓</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度/04"><span>12 | 分布式调度架构之两层调度：物质文明、精神文明两手抓</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度/05"><span>13 | 分布式调度架构之共享状态调度：物质文明、精神文明多手协商抓</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/03.第二站分布式资源管理与负载调度/06"><span>14 | 答疑篇：分布式事务与分布式锁相关问题</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/04.第三站分布式计算技术">04.第三站分布式计算技术</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/04.第三站分布式计算技术/01"><span>15 | 分布式计算模式之MR：一门同流合污的艺术</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/04.第三站分布式计算技术/02"><span>16 | 分布式计算模式之Stream：一门背锅的艺术</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/04.第三站分布式计算技术/03"><span>17 | 分布式计算模式之Actor：一门甩锅的艺术</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/04.第三站分布式计算技术/04"><span>18 | 分布式计算模式之流水线：你方唱罢我登场</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/05.第四站分布式通信技术">05.第四站分布式通信技术</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/05.第四站分布式通信技术/01"><span>19 | 分布式通信之远程调用：我是你的千里眼</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/05.第四站分布式通信技术/02"><span>20 | 分布式通信之发布订阅：送货上门</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/05.第四站分布式通信技术/03"><span>21 | 分布式通信之消息队列：货物自取</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/05.第四站分布式通信技术/04"><span>22 | 答疑篇：分布式体系架构与分布式计算相关问题</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/06.第五站分布式数据存储">06.第五站分布式数据存储</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/06.第五站分布式数据存储/01"><span>23 | CAP理论：这顶帽子我不想要</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/06.第五站分布式数据存储/02"><span>24 | 分布式数据存储系统之三要素：顾客、导购与货架</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/06.第五站分布式数据存储/03"><span>25 | 数据分布方式之哈希与一致性哈希：“掐指一算”与“掐指两算”的事</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/06.第五站分布式数据存储/04"><span>26 | 分布式数据复制技术：分身有术</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/06.第五站分布式数据存储/05"><span>27 | 分布式数据之缓存技术：“身手钥钱”随身带</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/07.第六站分布式高可靠">07.第六站分布式高可靠</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/07.第六站分布式高可靠/01"><span>28 | 分布式高可靠之负载均衡：不患寡，而患不均</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/07.第六站分布式高可靠/02"><span>29 | 分布式高可靠之流量控制：大禹治水，在疏不在堵</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/07.第六站分布式高可靠/03"><span>30 | 分布式高可用之故障隔离：当断不断，反受其乱</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/07.第六站分布式高可靠/04"><span>31 | 分布式高可用之故障恢复：知错能改，善莫大焉</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/07.第六站分布式高可靠/05"><span>32 | 答疑篇：如何判断并解决网络分区问题？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲">08.第七站分布式核心知识串讲</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/01"><span>33 | 知识串联：以购买火车票的流程串联分布式核心技术</span></a></li><li><a aria-current="page" class="active" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02"><span>34 | 搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/09.结束语">09.结束语</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/09.结束语/01"><span>结束语 | 为什么说提升职业竞争力要从尊重、诚实开始？</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/09.结束语/02"><span>结课测试 | 关于分布式的这些知识点，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送">10.特别放送</a><ul><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送/01"><span>特别放送 | 徐志强：学习这件事儿，不到长城非好汉</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送/02"><span>特别放送 | 那些你不能错过的分布式系统论文</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送/03"><span>特别放送 | 分布式下的一致性杂谈</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送/04"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送/05"><span>特别放送 | 崔新：追根溯源，拨开云雾见青天</span></a></li><li><a href="/blog-architect2/分布式技术原理与算法解析/10.特别放送/06"><span>特别放送 | Jackey：寄语天涯客，轻寒底用愁</span></a></li></ul></li><li><a href="/blog-architect2/分布式技术原理与算法解析/summary">分布式技术原理与算法解析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="搭建目标" data-depth="2"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#搭建目标"><span>搭建目标</span></a></li><li title="搭建前的准备" data-depth="2"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#搭建前的准备"><span>搭建前的准备</span></a></li><li title="Kubernetes集群搭建" data-depth="2"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#kubernetes集群搭建"><span>Kubernetes集群搭建</span></a></li><li title="1. 安装Docker" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#1-安装docker"><span>1. 安装Docker</span></a></li><li title="2. 安装部署kubeadm、kubelet、kubectl" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#2-安装部署kubeadmkubeletkubectl"><span>2. 安装部署kubeadm、kubelet、kubectl</span></a></li><li title="3. 部署Master节点" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#3-部署master节点"><span>3. 部署Master节点</span></a></li><li title="4. 部署Worker节点" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#4-部署worker节点"><span>4. 部署Worker节点</span></a></li><li title="5. 安装网络插件" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#5-安装网络插件"><span>5. 安装网络插件</span></a></li><li title="6. 验证" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#6-验证"><span>6. 验证</span></a></li><li title="7. 可能遇到的问题" data-depth="3"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#7-可能遇到的问题"><span>7. 可能遇到的问题</span></a></li><li title="Nginx服务部署" data-depth="2"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#nginx服务部署"><span>Nginx服务部署</span></a></li><li title="总结" data-depth="2"><a href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="34--搭建一个分布式实验环境纸上得来终觉浅绝知此事要躬行"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#34--搭建一个分布式实验环境纸上得来终觉浅绝知此事要躬行"><span class="icon icon-link"></span></a>34 | 搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行</h1><p>你好，我是聂鹏程。</p><p>上一讲，我以购买火车票为例，为你串讲了分布式技术的应用，帮助你理解所学分布式技术可以应用到哪些业务中。其实，到目前为止，我们主要是从理论上学习相关的分布式技术。但，“纸上得来终觉浅，绝知此事要躬行”。</p><p>今天，我就以Kubernetes为例，和你一起搭建一个分布式实验环境。我先简单和你说下这篇文章的内容分配：</p><ul><li>不会特别详细地讲述搭建过程，而是着重说明搭建的主要步骤以及可能遇到的问题；</li><li>在讲述搭建过程时，串联一下其中涉及的分布式相关知识；</li><li>搭建完Kubernetes集群之后，我会以部署Nginx服务为例，帮助你更直观地体验分布式技术，以巩固、加深对分布式技术的理解。</li></ul><p>话不多说，接下来，我们就一起搭建这个分布式实验环境吧。</p><h2 id="搭建目标"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#搭建目标"><span class="icon icon-link"></span></a>搭建目标</h2><p>Kubernetes是Google开源的容器集群管理系统，是Borg的开源版本。我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/148187">第9篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中讲解集中式架构时，和你分析过Kubernetes集群属于主从架构的分布式集群。</p><p>Kubernetes集群主要由Master节点和Worker节点组成。Master节点就是中心服务器，负责对集群进行调度管理；Worker节点是真正的工作节点，负责运行业务应用的容器。而容器是一种虚拟化技术，通过限制自身使用的资源来实现资源隔离，可以为应用提供一整套运行环境，从而实现了服务运行环境的隔离，进而实现了故障隔离。你可以回顾下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/175213">第30篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，资源隔离的相关内容。</p><p>接下来，我们明确下这次搭建分布式实验室环境的目标：</p><ul><li>搭建一个Kubernetes集群，包括一个Master节点，两个Worker节点;</li><li>在Kubernetes集群上创建一个Nginx服务。</li></ul><h2 id="搭建前的准备"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#搭建前的准备"><span class="icon icon-link"></span></a>搭建前的准备</h2><p>今天我们要搭建的Kubernetes集群，以3台服务器为例，一台作为Master节点，两台作为Worker节点。服务器应具备的条件如下：</p><ul><li>Ubuntu 16.04操作系统；</li><li>2GB或以上的内存；</li><li>2核CPU或以上；</li><li>服务器间网络连通；</li><li>每台服务器具有唯一的主机名、MAC地址和product_uuid；</li><li>通过执行命令swapoff -a来关闭Swap；</li><li>30GB及以上的磁盘空间；</li><li>具备外网访问权限，以方便获取相关镜像。</li></ul><p>在这次部署中，我采用的机器配置如下：</p><p><img src="/blog-architect2/static/httpsstatic001geekbangorgresourceimagea95ea96f67cb7fc7df583f73c098d377f55e.d1a3b157.jpg" alt=""/></p><p>准备工作完成后，我们就开始搭建集群吧。</p><h2 id="kubernetes集群搭建"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#kubernetes集群搭建"><span class="icon icon-link"></span></a>Kubernetes集群搭建</h2><p>搭建Kubernetes集群的步骤，主要包括安装Docker，安装部署kubeadm、kubelet、kubectl，部署Master节点，部署Worker节点，安装网络插件这几步。</p><p>其中，安装Docker、部署Master节点和Worker节点涉及分布式的，需要在多个节点上部署，比如Docker节点需要在每个Worker节点部署，Master节点若为集群模式，需要在多个节点上配置主备，Worker节点需要与Master节点建立连接等。</p><p>接下来， 我们具体看看如何一步一步搭建出Kubernetes集群吧。</p><h3 id="1-安装docker"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#1-安装docker"><span class="icon icon-link"></span></a>1. 安装Docker</h3><p>Kubernetes是一个容器集群管理系统，因此每个Worker节点会运行容器，以实现业务运行环境隔离。我们在每台服务器上采用如下命令安装Docker：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt-get install -y docker.io</span></div></pre></div><h3 id="2-安装部署kubeadmkubeletkubectl"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#2-安装部署kubeadmkubeletkubectl"><span class="icon icon-link"></span></a>2. 安装部署kubeadm、kubelet、kubectl</h3><p>kubeadm是Kubernetes社区提供的一个部署工具，该工具将kubelet组件之外的其他组件均采用容器部署，实现了自动化， 避免了手动部署容器的麻烦，简化了部署操作。</p><p>其中，Master节点包括API Server、Scheduler、Cluster State Store(默认etcd)和Control Manager Srever核心组件；Worker节点包括kubelet和kube-proxy核心组件。具体的组件功能和原理，你可以再回顾下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/148187">第9篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的相关内容。</p><p>kubelet组件本身是一个管控容器的组件，需要执行配置容器网络等操作，这些操作需要在宿主机上执行，不采用容器部署。因此，kubelet组件需要单独部署，而不能用kubeadm进行部署。</p><p>除此之外，我们还需要安装一下kubectl组件。这个组件是Kubernetes的命令行工具，通过kubectl可以部署和管理应用，查看资源，创建、删除和更新组件。</p><p>那么，如何部署kubeadm、kubelet和kubectl这三个组件呢？</p><p>apt是Linux下常用的安装管理工具，这里我就采用apt来安装这三个组件。</p><p>首先，我们需要添加Kubernetes源。</p><ul><li>你可以通过执行以下语句获取Kubernetes源（需要外网权限）：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span></div><div class="token-line"><span class="token plain">    curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span></div><div class="token-line"><span class="token plain">    cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span></div><div class="token-line"><span class="token plain">    deb https://apt.kubernetes.io/ kubernetes-xenial main</span></div><div class="token-line"><span class="token plain">    EOF</span></div></pre></div><p>然后使用以下命令更新源：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo apt-get update</span></div></pre></div><ul><li>这时，我们就可以使用如下命令来安装kubelet、kubectl和kubeadm了：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo apt-get install -y kubelet kubeadm kubectl</span></div></pre></div><ul><li>如果没有外网访问权限，在添加kubernetes源的时候可以执行以下命令来添加阿里云的Kubernetes源：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span></div><div class="token-line"><span class="token plain">    deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main</span></div><div class="token-line"><span class="token plain">    EOF</span></div></pre></div><p>同样的，使用以下命令来更新源：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt-get update # 忽略gpg的报错信息</span></div></pre></div><p>最后，使用如下命令安装kubelet、kubectl和kubeadm：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt-get install -y kubelet kubeadm kubectl --allow-unauthenticated</span></div></pre></div><p>安装好这三个组件之后，我们就可以使用kubeadm来一键部署集群节点了。</p><p>首先，我们来部署Master节点。</p><h3 id="3-部署master节点"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#3-部署master节点"><span class="icon icon-link"></span></a>3. 部署Master节点</h3><p>这一步其实就是容器化启动Master节点中的各个组件，直接使用kubeadm工具提供的一条命令kubeadm init即可自动安装。</p><p>kubeadm init这条命令底层其实就是将Master的各个组件，比如API Server、etcd等，以Pod形式（容器集合）运行起来。</p><p>当然了，你可以部署多个Master节点来实现集群的高可用，比如两个Master节点互为主备（你可以回顾下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/175545">第31篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中介绍的主备机制）。具体的部署方法，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>除此之外，etcd组件也可以采用集群方式部署，从而保证了数据不会丢失。etcd采用的是Raft强一致性协议，相关技术你可以再回顾下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/143329">第4篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的相关问题。</p><p><strong>在本次部署中我以一个Master节点为例为你讲解集群的搭建</strong>，关于Master为集群的方式，各节点上kubernetes配置类似，你可以参考Kubernetes官网。</p><p>在这里，我把192.168.124.49这台机器作为Master节点。在该机器上直接执行kubeadm init，即可完成部署：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubeadm init</span></div></pre></div><p>如果有外网访问权限，基本就可以部署成功了。那么，我们可以根据如下信息判断自己是否部署成功：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Your Kubernetes control-plane has initialized successfully!</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    To start using your cluster, you need to run the following as a regular user:</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      mkdir -p $HOME/.kube</span></div><div class="token-line"><span class="token plain">      sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></div><div class="token-line"><span class="token plain">      sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    You should now deploy a pod network to the cluster.</span></div><div class="token-line"><span class="token plain">    Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span></div><div class="token-line"><span class="token plain">      https://kubernetes.io/docs/concepts/cluster-administration/addons/</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Then you can join any number of worker nodes by running the following on each as root:</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    kubeadm join 192.168.124.49:6443 --token uv17vd.q3ber8i5knxg4h0x \</span></div><div class="token-line"><span class="token plain">        --discovery-token-ca-cert-hash sha256:c55bd70d346d809e1079565cc1fc1a05f001671cc9f2d02c55bbbc4a00bcc2a3</span></div></pre></div><p>可以看到，想要使用集群，需要执行以下命令，执行结束后才可以使用kubectl。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mkdir -p $HOME/.kube</span></div><div class="token-line"><span class="token plain">    cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></div><div class="token-line"><span class="token plain">    chown $(id -u):$(id -g) $HOME/.kube/config</span></div></pre></div><p>如果没有外网访问权限，会报pull image xxxxxx的错误。</p><p>此时不要慌，从报错信息中，我们可以看到哪些镜像拉取不成功。我们可以手动在Docker Hub上寻找相对应的组件及版本，进行拉取，然后再通过Docker打tag，修改为需要的镜像。</p><p>比如，以[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.16.3为例，可以通过以下代码进行拉取。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 可以拉取的相对应的组件和版本</span></div><div class="token-line"><span class="token plain">    docker pull aiotceo/kube-apiserver:v1.16.3</span></div><div class="token-line"><span class="token plain">    # 通过打tag的方式修改为所需要的镜像</span></div><div class="token-line"><span class="token plain">    docker tag aiotceo/kube-apiserver:v1.16.3 k8s.gcr.io/kube-apiserver:v1.16.3</span></div></pre></div><p>然后重新执行 kubeadm init即可。</p><p>从以上操作也可以看出，<strong>kubeadm的底层其实就是将容器化组件的操作实现了自动化， 省去了手动部署的麻烦</strong>。</p><p>部署完Master节点后，我们来继续部署Worker节点。</p><h3 id="4-部署worker节点"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#4-部署worker节点"><span class="icon icon-link"></span></a>4. 部署Worker节点</h3><p>部署Worker节点与部署Master节点类似，都可以通过命令一键部署。这里，我们使用kubeadm提供的kubeadm join命令来进行自动化部署。</p><p>kubeadm join命令的底层与kubeadm init类似，会自动以Pod形式运行Worker节点中需要的组件。不同的是，命令执行后，底层还需要将Worker节点加入到Kubernetes集群中。</p><p>执行kubeadm join命令后（具体命令如下所示），就可以看到Kubernetes集群中的节点信息了。这条命令中需要配置Master节点的IP和Port信息，目的是Worker节点根据IP和Port信息建立连接，并在建立连接的基础上，建立心跳机制。</p><p>具体的心跳机制，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/175545">第31篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中关于故障恢复的内容。</p><p>到目前为止，Kubernetes的集群已经完成大半了，下面我们继续部署集群。</p><p>根据Master节点部署成功后输出结果的最后几行可以知道，想要加入集群，可以执行kubeadm join命令。我在另外2台机器上都执行了如下命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubeadm join 192.168.124.49:6443 --token uv17vd.q3ber8i5knxg4h0x \</span></div><div class="token-line"><span class="token plain">        --discovery-token-ca-cert-hash sha256:c55bd70d346d809e1079565cc1fc1a05f001671cc9f2d02c55bbbc4a00bcc2a3</span></div></pre></div><p>这条命令执行后，一个集中式架构的雏形就搭建完成了。接下来，我们需要安装相应的网络插件，以实现Kubernetes集群中Pod之间的通信。</p><h3 id="5-安装网络插件"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#5-安装网络插件"><span class="icon icon-link"></span></a>5. 安装网络插件</h3><p>网络插件有很多，比如Canal、Flannel、Weave等。不同的插件命令不一致，具体命令可参考官网。</p><p>这里，我以安装Weave插件为例，通过执行以下命令完成安装：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sysctl net.bridge.bridge-nf-call-iptables=1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#x27;\n&#x27;)&quot;</span></div></pre></div><h3 id="6-验证"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#6-验证"><span class="icon icon-link"></span></a>6. 验证</h3><p>到这里，集群就部署完成了，是不是很简单呢？接下来，我就通过获取节点和Pod信息来验证一下集群部署是否成功。</p><p>可以通过刚刚安装的kubectl组件提供的命令查看集群的相关信息。比如，查看节点的运行状态可以通过kubectl get nodes来获得，查看各个组件对应的Pod运行状态可以通过kubectl get pods来获得。命令执行结果，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubectl get nodes</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # NAME           STATUS   ROLES    AGE   VERSION</span></div><div class="token-line"><span class="token plain">    # vm1-pc   Ready    master   11h   v1.16.3</span></div><div class="token-line"><span class="token plain">    # vm2-pc   Ready    &lt;none&gt;   11h   v1.16.3</span></div><div class="token-line"><span class="token plain">    # vm3-pc   Ready    &lt;none&gt;   24m   v1.16.3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    kubectl get pods --all-namespaces</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # NAMESPACE     NAME                                   READY   STATUS    RESTARTS   AGE</span></div><div class="token-line"><span class="token plain">    # kube-system   coredns-5644d7b6d9-9dprc               1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   coredns-5644d7b6d9-ljv5w               1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   etcd-vm1-pc                      1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   kube-apiserver-vm1-pc            1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   kube-controller-manager-vm1-pc   1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   kube-proxy-qpvtb                       1/1     Running   0          25m</span></div><div class="token-line"><span class="token plain">    # kube-system   kube-proxy-v2xnb                       1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   kube-proxy-wkxzg                       1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   kube-scheduler-vm1-pc            1/1     Running   0          11h</span></div><div class="token-line"><span class="token plain">    # kube-system   weave-net-6nj4c                        2/2     Running   0          25m</span></div><div class="token-line"><span class="token plain">    # kube-system   weave-net-lm6dh                        2/2     Running   0          37m</span></div><div class="token-line"><span class="token plain">    # kube-system   weave-net-vwnc2                        2/2     Running   0          37m</span></div></pre></div><p>可以看到，节点全部是Ready状态，各个组件对应的Pod也处于Running状态，表明部署成功。</p><h3 id="7-可能遇到的问题"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#7-可能遇到的问题"><span class="icon icon-link"></span></a>7. 可能遇到的问题</h3><p>如果整个安装失败的话，可以重置，重新安装，即重新kubeadm init</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubeadm reset</span></div></pre></div><p>部署Worker节点时，pod部署不成功。原因可能是因为没有外网访问权限，镜像拉取不下来，可以通过以下命令查看pod的相关信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 检查所有pod是否正常</span></div><div class="token-line"><span class="token plain">    kubectl get pod --all-namespaces -o wide</span></div><div class="token-line"><span class="token plain">    #如果pod处于非running状态，则查看该pod：</span></div><div class="token-line"><span class="token plain">    kubectl describe pod xxxxx -n kube-system</span></div></pre></div><p>从错误信息里可以查看到是哪个镜像拉取不下来，与部署Master节点时采用的方式一样，到Docker Hub上手动拉取镜像，并设置Tag即可。</p><p>至此，Kubernetes集群就配置成功了。</p><p>集群环境搭建后，如何验证集群是可用的呢？或者说，如何在集群上运行服务呢？接下来，我就以Nginx服务为例，带你了解如何在Kubernetes集群上进行服务部署。当然，你可以参考这个例子，在Kubernetes集群上部署其他服务。</p><h2 id="nginx服务部署"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#nginx服务部署"><span class="icon icon-link"></span></a>Nginx服务部署</h2><p>Kubernetes推荐使用YAML配置文件的方式来创建服务，所以我接下来会使用这种方式部署完成Nginx服务的部署。</p><p>部署Nginx服务这个Demo时，我会创建两个Kubernetes对象（Kubernetes对象是Kubernetes系统中的持久实体，用于表示集群的状态），一个是Deployment，一个是Service：</p><ul><li>Deployment对象规定Pod创建的相关信息，比如期望创建几个Pod，每个Pod应该部署什么应用等。</li><li>Service对象用来给用户访问提供接口。它可以通过Label Selector（标签选择器）来指定可以访问的Pod有哪些。关于Kubernetes对象的相关内容，你可以参考<a target="_blank" rel="noopener noreferrer" href="http://docs.kubernetes.org.cn/232.html">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ul><p>因为Pod是Kubernetes中最小的工作单元，所以Nginx服务都部署在Pod中。下面，我就来创建一个Deployment对象来创建我们期望的Pod状态。</p><p>首先，创建一个YAML配置文件，我将其命名为nginx-deployment.yaml。为将用户请求负载均衡到不同的Pod，减轻单个Pod的访问压力，这里我会创建三个Pod共同运行Nginx服务。</p><p>文件内容如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: apps/v1</span></div><div class="token-line"><span class="token plain">    kind: Deployment</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: nginx-deployment</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: nginx</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      replicas: 3</span></div><div class="token-line"><span class="token plain">      selector:</span></div><div class="token-line"><span class="token plain">        matchLabels:</span></div><div class="token-line"><span class="token plain">          app: nginx</span></div><div class="token-line"><span class="token plain">      template:</span></div><div class="token-line"><span class="token plain">        metadata:</span></div><div class="token-line"><span class="token plain">          labels:</span></div><div class="token-line"><span class="token plain">            app: nginx</span></div><div class="token-line"><span class="token plain">        spec:</span></div><div class="token-line"><span class="token plain">          containers:</span></div><div class="token-line"><span class="token plain">          - name: nginx</span></div><div class="token-line"><span class="token plain">            image: nginx:latest</span></div><div class="token-line"><span class="token plain">            ports:</span></div><div class="token-line"><span class="token plain">            - containerPort: 80</span></div></pre></div><p>文件中，replicas字段就是副本数量，也就是Pod数量，设置为3，即创建三个Pod来运行Nginx服务；template字段规定了单个Pod中运行哪些容器，这里运行的是名称为nginx的容器。</p><ul><li>创建完配置文件后，通过以下命令就可以将Deployment对象创建成功。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubectl apply -f nginx-deployment.yaml</span></div></pre></div><p>执行后，就等待对象的创建，可以通过以下命令来查看创建是否成功。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubectl get deployment</span></div></pre></div><p>以下是我创建成功后的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span></div><div class="token-line"><span class="token plain">    nginx-deployment   3/3     3            3           3m17s</span></div></pre></div><p>同时，你也可以通过以下命令来查看创建的Pod的信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubectl get pod</span></div></pre></div><p>以下是我的输出结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">NAME                               READY   STATUS    RESTARTS   AGE</span></div><div class="token-line"><span class="token plain">    nginx-deployment-59c9f8dff-dtg4w   1/1     Running   0          3m15s</span></div><div class="token-line"><span class="token plain">    nginx-deployment-59c9f8dff-f2hmv   1/1     Running   0          3m15s</span></div><div class="token-line"><span class="token plain">    nginx-deployment-59c9f8dff-lsvdh   1/1     Running   0          3m15s</span></div></pre></div><p>创建完deployment之后，我们来创建Service服务。同样是通过配置文件来创建，文件名是nginx-service.yaml，内容如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Service</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: nginx-service</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: nginx</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      ports:</span></div><div class="token-line"><span class="token plain">      - port: 88</span></div><div class="token-line"><span class="token plain">        targetPort: 80</span></div><div class="token-line"><span class="token plain">      selector:</span></div><div class="token-line"><span class="token plain">        app: nginx</span></div><div class="token-line"><span class="token plain">      type: NodePort</span></div></pre></div><p>文件中port属性就是service对外提供的端口。</p><p>同样的，采用kubectl apply命令创建Nginx服务：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubectl apply -f nginx-service.yaml</span></div></pre></div><p>执行完成后，可以通过以下命令来查看创建是否成功：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">kubectl get service</span></div></pre></div><p>以下是我的输出结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span></div><div class="token-line"><span class="token plain">    kubernetes      ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          12h</span></div><div class="token-line"><span class="token plain">    nginx-service   NodePort    10.101.29.9      &lt;none&gt;        88:30755/TCP     5m12s</span></div></pre></div><p>现在我们就可以通过访问Nginx服务来查看它是否部署成功了。访问该服务可以通过以下命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">curl 10.101.29.9:88</span></div></pre></div><p>结果如下，表明Nginx服务部署成功。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;head&gt;</span></div><div class="token-line"><span class="token plain">    &lt;title&gt;Welcome to nginx!&lt;/title&gt;</span></div><div class="token-line"><span class="token plain">    &lt;style&gt;</span></div><div class="token-line"><span class="token plain">        body {</span></div><div class="token-line"><span class="token plain">            width: 35em;</span></div><div class="token-line"><span class="token plain">            margin: 0 auto;</span></div><div class="token-line"><span class="token plain">            font-family: Tahoma, Verdana, Arial, sans-serif;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    &lt;/style&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/head&gt;</span></div><div class="token-line"><span class="token plain">    &lt;body&gt;</span></div><div class="token-line"><span class="token plain">    &lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">    &lt;p&gt;If you see this page, the nginx web server is successfully installed and</span></div><div class="token-line"><span class="token plain">    working. Further configuration is required.&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;p&gt;For online documentation and support please refer to</span></div><div class="token-line"><span class="token plain">    &lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span></div><div class="token-line"><span class="token plain">    Commercial support is available at</span></div><div class="token-line"><span class="token plain">    &lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/html&gt;</span></div></pre></div><p>在这个过程中，有两个步骤涉及<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/173398">负载均衡<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的相关知识：</p><ul><li>一个是创建Deployment时，该Deployment会创建三个Pod，而Pod需要部署到某个Worker节点中，因此会将Pod均衡部署到各个Worker节点中；</li><li>另一个是用户访问，Nginx服务后台三个运行的Pod都可以提供服务，用户访问到来时，可以均衡分布到各个Pod中进行处理。</li></ul><p>到这里，我们搭建的目标就完成了，下面为你留几个实验题，你可以尝试去搭建一下或运行一下，以进一步加深对分布式技术的理解。</p><ul><li>实验一：搭建高可用Kubernetes集群，也就是通过etcd实现Master节点以集群模式部署。具体搭建方法可参考<a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li><li>实验二：在Kubernetes上部署Cassandra，其中Cassandra作为服务部署到容器中，以学习Cassandra集群的节点发现、集群组件等原理，具体搭建方法可参考<a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/docs/tutorials/stateful-application/cassandra/">https://kubernetes.io/docs/tutorials/stateful-application/cassandra/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li><li>实验三：在Kubernetes集群上通过部署一个MySQL服务，体验在Kubernetes集群上如何运行一个单实例有状态应用。具体搭建方法可参考<a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/">https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ul><p>好了，整个搭建环境，我就讲到这里。</p><p>其实，到这里，对分布式世界的探索可以说才刚开始，只有动手去实践，你学到的知识才能真正转化为你自己的。加油，赶紧行动起来吧。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-architect2/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天，我主要带你学习了搭建分布式实验环境。</p><p>首先，我以Kubernetes为例，介绍了如何搭建 Kubernetes集群环境，其中包括容器、Master节点、Worker节点等配置和安装。</p><p>然后，在搭建好的Kubernetes集群的基础上，我以Nginx服务为例，展示了如何在Kubernetes集群上部署服务。</p><p>其实，今天我演示的Demo只是冰山一角。在Kubernetes中，有很多非常实用的功能，比如Kubernetes可以让服务持续不断运行，当有Pod出现故障时，会自动重启另一个Pod来达到Deployment配置文件中规定的期望状态；还可以自动实现版本更迭等。</p><p>相信通过本讲的学习，你会对分布式技术有更进一步的认知。加油，赶紧行动起来，为你的服务搭建一个分布式实验环境吧。</p><p>我是聂鹏程，感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再会！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/分布式技术原理与算法解析/08.第七站分布式核心知识串讲/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:38:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect2/umi.e65758f7.js"></script>
  </body>
</html>
